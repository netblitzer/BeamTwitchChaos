/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/styles/index.less":
/*!*******************************!*\
  !*** ./src/styles/index.less ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://beamtwitchchaos/./src/styles/index.less?");

/***/ }),

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   app: () => (/* binding */ app),\n/* harmony export */   settings: () => (/* binding */ settings)\n/* harmony export */ });\n/* harmony import */ var _connection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./connection */ \"./src/js/connection.js\");\n/* harmony import */ var _ui_effects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ui-effects */ \"./src/js/ui-effects.js\");\n\r\n\r\n\r\nconst settings = {\r\n  autoConnect: false,\r\n}\r\n\r\nconst loadSettings = (loaded) => {\r\n  const settingsKeys = Object.keys(loaded)\r\n  settingsKeys.forEach(setKey => {\r\n    settings[setKey] = loaded[setKey]\r\n  })\r\n}\r\n\r\nconst app = (scope, element) => {\r\n  scope.rootElement = element[0]\r\n  ;(0,_connection__WEBPACK_IMPORTED_MODULE_0__.initialize)(scope)\r\n  ;(0,_ui_effects__WEBPACK_IMPORTED_MODULE_1__.initialize)(scope)\r\n\r\n  scope.$on('BTCApplySettings', (e, data) => {\r\n    //console.dir(e)\r\n    loadSettings(data)\r\n  })\r\n  scope.$on('BTCSettingsSaved', (e) => {\r\n    //console.dir(e)\r\n  })\r\n\r\n  bngApi.engineLua(`freeroam_beamTwitchChaos.loadSettingsFile()`)\r\n  bngApi.engineLua(`freeroam_beamTwitchChaos.checkServerStatus()`)\r\n}\r\n\n\n//# sourceURL=webpack://beamtwitchchaos/./src/js/app.js?");

/***/ }),

/***/ "./src/js/connection.js":
/*!******************************!*\
  !*** ./src/js/connection.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONNECTION_STATUS: () => (/* binding */ CONNECTION_STATUS),\n/* harmony export */   CONNECTION_STATUS_LABELS: () => (/* binding */ CONNECTION_STATUS_LABELS),\n/* harmony export */   initialize: () => (/* binding */ initialize)\n/* harmony export */ });\n/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./app */ \"./src/js/app.js\");\n/* harmony import */ var _ui_effects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ui-effects */ \"./src/js/ui-effects.js\");\n\r\n\r\n\r\nconst CONNECTION_STATUS = {\r\n  CONNECTED: 'connected',\r\n  DISCONNECTED: 'disconnected',\r\n  LOST_CONNECTION: 'lost_connection',\r\n  RECONNECT: 'reconnecting',\r\n}\r\n\r\nconst CONNECTION_STATUS_LABELS = {\r\n  [CONNECTION_STATUS.CONNECTED]: 'Connected',\r\n  [CONNECTION_STATUS.DISCONNECTED]: 'Disconnected',\r\n  [CONNECTION_STATUS.LOST_CONNECTION]: 'Lost Connection',\r\n  [CONNECTION_STATUS.RECONNECT]: 'Reconnecting...',\r\n}\r\n\r\nconst state = {\r\n  status: CONNECTION_STATUS.DISCONNECTED,\r\n  statusEle: null,\r\n  lastConnectionAttemptTime: null,\r\n  lastConnectionAttemptCount: 0,\r\n  lastConnectionAttemptInterval: null,\r\n  currentCombo: 0,\r\n}\r\nconst elements = {\r\n  status: null,\r\n  statusText: null,\r\n  connect: null,\r\n  reconnect: null,\r\n  disconnect: null,\r\n  boardEle: null,\r\n  comboLevel: null,\r\n  comboInner: null,\r\n  comboHighest: null,\r\n  comboOnes: null,\r\n  comboTens: null,\r\n  comboHund: null,\r\n  vehicleLoadText: null,\r\n}\r\nlet debugEl = null\r\n\r\nconst tryServerConnect = (connectionAttempts = 0) => {\r\n  if (connectionAttempts === 0 && state.lastConnectionAttemptInterval) {\r\n    clearTimeout(state.lastConnectionAttemptInterval)\r\n  }\r\n\r\n  state.status = CONNECTION_STATUS.RECONNECT\r\n  elements.statusText.textContent = CONNECTION_STATUS_LABELS[state.status]\r\n  elements.status.dataset.status = state.status\r\n\r\n  if (connectionAttempts < 5) {\r\n    console.warn(\"reconnection attempt: %d\", connectionAttempts + 1)\r\n    bngApi.engineLua(`freeroam_beamTwitchChaos.connectToServer()`)\r\n    state.lastConnectionAttemptTime = new Date().getUTCMilliseconds()\r\n    state.lastConnectionAttemptCount += 1\r\n    state.lastConnectionAttemptInterval =\r\n      setTimeout(\r\n        () => tryServerConnect(state.lastConnectionAttemptCount),\r\n        state.lastConnectionAttemptCount * 1000)\r\n  } else {\r\n    state.lastConnectionAttemptTime = null\r\n    state.lastConnectionAttemptInterval = null\r\n    state.lastConnectionAttemptCount = 0\r\n    state.status = CONNECTION_STATUS.DISCONNECTED\r\n    elements.statusText.textContent = CONNECTION_STATUS_LABELS[state.status]\r\n    elements.status.dataset.status = state.status\r\n    elements.disconnect.classList.add('btc-hidden')\r\n    elements.reconnect.classList.add('btc-hidden')\r\n    elements.connect.classList.remove('btc-hidden')\r\n  }\r\n}\r\n\r\nconst triggerCommandAlert = (commandData) => {\r\n  if (commandData.code.indexOf('cc_') === 0 && commandData.code !== 'cc_activate'\r\n      && commandData.code !== 'cc_continue.1' && commandData.code !== 'cc_continue.2') {\r\n    (0,_ui_effects__WEBPACK_IMPORTED_MODULE_1__.addCCEffect)(commandData)\r\n  }\r\n\r\n  const alertMidTime = 2350\r\n  const alertEndTime = 150\r\n  const alert = document.createElement('div')\r\n  alert.classList.add('btc-effect-alert', 'btc-effect-alert-start')\r\n  alert.dataset.alertId = commandData.id\r\n\r\n  let message = 'triggered a random command'\r\n  switch (commandData.code) {\r\n    case 'dvd_1':\r\n    case 'dvd_5':\r\n    case 'dvd_10':\r\n    case 'dvd':\r\n      message = 'added DVD logos'\r\n      break;\r\n    case 'ad_1':\r\n    case 'ad_5':\r\n    case 'ad_10':\r\n    case 'ad':\r\n      message = 'added ads'\r\n      break;\r\n    case 'view_narrow':\r\n    case 'view_squish':\r\n    case 'view_shake':\r\n      message = 'wants to see less'\r\n      break;\r\n    case 'pop':\r\n      message = 'triggered a tire to pop'\r\n      break;\r\n    case 'alarm':\r\n      message = 'thinks this car is stolen'\r\n      break;\r\n    case 'ignition':\r\n      message = 'doesn\\'t want to keep moving'\r\n      break;\r\n    case 'fire':\r\n      message = 'triggered the car to catch fire'\r\n      break;\r\n    case 'explode':\r\n      message = 'triggered the car to explode'\r\n      break;\r\n    case 'nudge_l':\r\n    case 'nudge_r':\r\n    case 'kick_l':\r\n    case 'kick_r':\r\n      message = 'gave a bit of a nudge'\r\n      break;\r\n    case 'tilt_l':\r\n    case 'tilt_r':\r\n    case 'roll_l':\r\n    case 'roll_r':\r\n      message = 'went car tipping'\r\n      break;\r\n    case 'boost_l':\r\n    case 'boost_h':\r\n      message = 'engaged boost'\r\n      break;\r\n    case 'jump_l':\r\n    case 'jump_h':\r\n      message = 'wants to jump this car'\r\n      break;\r\n    case 'sticky_throttle':\r\n      message = 'wants to go faster'\r\n      break;\r\n    case 'sticky_brake':\r\n      message = 'wants to go slower'\r\n      break;\r\n    case 'sticky_parkingbrake':\r\n      message = 'wants to drift'\r\n      break;\r\n    case 'sticky_turn_l':\r\n    case 'sticky_turn_r':\r\n      message = 'wants to go that way'\r\n      break;\r\n    case 'extinguish':\r\n      message = 'extinguished the car'\r\n      break;\r\n    case 'ghost':\r\n      message = 'invited a ghost'\r\n      break;\r\n    case 'daytime':\r\n      message = 'turned the lights on'\r\n      break;\r\n    case 'nighttime':\r\n      message = 'turned the lights off'\r\n      break;\r\n    case 'randomtime':\r\n      message = 'turned the lights somewhere'\r\n      break;\r\n    case 'timescale':\r\n      message = 'spun the world really fast'\r\n      break;\r\n    case 'gravity_grav_pluto':\r\n    case 'gravity_grav_moon':\r\n    case 'gravity_grav_mars':\r\n    case 'gravity_grav_venus':\r\n    case 'gravity_grav_saturn':\r\n    case 'gravity_grav_jupiter':\r\n    case 'gravity_grav_double_earth':\r\n    case 'gravity':\r\n      message = 'wants to feel like they\\'re on another planet'\r\n      break;\r\n    case 'simscale':\r\n      message = 'wants to see that in slow-motion'\r\n      break;\r\n    case 'fix_env':\r\n      message = 'wants to go back to things being normal'\r\n      break;\r\n    case 'camera_change':\r\n      message = 'wants a better view'\r\n      break;\r\n    case 'camera_up':\r\n    case 'camera_down':\r\n    case 'camera_right':\r\n    case 'camera_left':\r\n    case 'camera_in':\r\n    case 'camera_out':\r\n      message = 'wants to look that way'\r\n      break;\r\n    case 'drop_cone':\r\n      message = 'tossed a cone your way'\r\n      break;\r\n    case 'drop_piano':\r\n      message = 'wants to hear some music'\r\n      break;\r\n    case 'drop_taxi':\r\n      message = 'hailed a cab'\r\n      break;\r\n    case 'drop_bus':\r\n      message = 'wants to get off at the next bus stop'\r\n      break;\r\n    case 'drop_traffic':\r\n      message = 'spotted some traffic up ahead'\r\n      break;\r\n    case 'kickflip':\r\n      message = 'wants to see some sick tricks'\r\n      break;\r\n    case 'spin':\r\n      message = 'forgot something at our last stop'\r\n      break;\r\n    case 'slam':\r\n      message = 'thinks this is a lowrider'\r\n      break;\r\n    case 'random_paint':\r\n      message = 'thought up a nice paint scheme'\r\n      break;\r\n    case 'random_tune':\r\n      message = 'messed with the tuning sliders'\r\n      break;\r\n    case 'random_part':\r\n      message = 'rummaged through a spare parts bin'\r\n      break;\r\n    case 'meteors':\r\n      message = 'spotted something in the sky'\r\n      break;\r\n    case 'fireworks':\r\n      message = 'wants to see some fireworks'\r\n      break;\r\n    case 'uireset':\r\n      message = 'cleaned up the view'\r\n      break;\r\n    case 'cc_activate':\r\n      message = 'wants to prove they\\'re a better driver'\r\n      break;\r\n    case 'cc_continue.1':\r\n    case 'cc_continue.2':\r\n      message = 'won\\'t let go of the wheel'\r\n      break;\r\n    case 'clippy':\r\n      message = 'thinks you need some help driving'\r\n      break;\r\n    case 'windows_error':\r\n      message = 'might have tweaked your bios'\r\n      break;\r\n    case 'repair':\r\n      message = 'thinks you might need some bondo'\r\n      break;\r\n    case 'reset':\r\n      message = 'did some necromancy'\r\n      break;\r\n    case 'test':\r\n      message = 'triggered the test command somehow'\r\n      break;\r\n    default:\r\n      message = 'triggered a mystery command'\r\n  }\r\n  alert.innerText = `${commandData.viewer} ${message}`\r\n  setTimeout(() => {\r\n    alert.classList.remove('btc-effect-alert-start')\r\n    setTimeout(() => {\r\n      alert.classList.add('btc-effect-alert-end')\r\n      setTimeout(() => {\r\n        alert.remove()\r\n      }, alertEndTime)\r\n    }, alertMidTime)\r\n  }, 1)\r\n  elements.boardEle.append(alert)\r\n}\r\n\r\nconst initialize = (scope) => {\r\n  elements.boardEle = scope.rootElement.querySelector('.btc-alert-container')\r\n  elements.comboLevel = scope.rootElement.querySelector('.btc-combo-level')\r\n  elements.comboHighest = scope.rootElement.querySelector('.btc-combo-highest')\r\n  elements.comboInner = scope.rootElement.querySelector('.btc-combo-count-inner')\r\n  elements.comboOnes = scope.rootElement.querySelector('#btc-ones')\r\n  elements.comboTens = scope.rootElement.querySelector('#btc-tens')\r\n  elements.comboHund = scope.rootElement.querySelector('#btc-hund')\r\n  elements.vehicleLoadText = elements.boardEle.querySelector('#btc-vehicle-countdown')\r\n\r\n  elements.status = scope.rootElement.querySelector('#btc-server-status-container')\r\n  elements.statusText = scope.rootElement.querySelector('#btc-server-status-text')\r\n  elements.statusText.textContent = CONNECTION_STATUS_LABELS[state.status]\r\n  elements.status.dataset.status = state.status\r\n\r\n  elements.disconnect = scope.rootElement.querySelector('#btc-disconnect-server')\r\n  elements.connect = scope.rootElement.querySelector('#btc-connect-server')\r\n  elements.reconnect = scope.rootElement.querySelector('#btc-reconnect-server')\r\n\r\n  debugEl = scope.rootElement.querySelector('#debug-text')\r\n\r\n  scope.$on('BTCServerConnected', () => {\r\n    if (state.status === CONNECTION_STATUS.LOST_CONNECTION\r\n      || state.lastConnectionAttemptInterval) {\r\n      console.log('connected')\r\n      state.status = CONNECTION_STATUS.CONNECTED\r\n      elements.statusText.textContent = CONNECTION_STATUS_LABELS[state.status]\r\n      elements.status.dataset.status = state.status\r\n\r\n      clearTimeout(state.lastConnectionAttemptInterval)\r\n      state.lastConnectionAttemptTime = null\r\n      state.lastConnectionAttemptInterval = null\r\n      state.lastConnectionAttemptCount = 0\r\n    }\r\n\r\n    elements.disconnect.classList.remove('btc-hidden')\r\n    elements.reconnect.classList.remove('btc-hidden')\r\n    elements.connect.classList.add('btc-hidden')\r\n  })\r\n  scope.$on('BTCServerDisconnected', () => {\r\n    console.log('disconnected')\r\n    state.status = CONNECTION_STATUS.DISCONNECTED\r\n    elements.statusText.textContent = CONNECTION_STATUS_LABELS[state.status]\r\n    elements.status.dataset.status = state.status\r\n\r\n    elements.disconnect.classList.add('btc-hidden')\r\n    elements.reconnect.classList.add('btc-hidden')\r\n    elements.connect.classList.remove('btc-hidden')\r\n  })\r\n  scope.$on('BTCServerLostConnection', () => {\r\n    console.log('lost connection')\r\n    state.status = CONNECTION_STATUS.LOST_CONNECTION\r\n    elements.status.dataset.status = state.status\r\n    elements.statusText.textContent = CONNECTION_STATUS_LABELS[state.status]\r\n    setTimeout(() => {\r\n      if (state.status === CONNECTION_STATUS.LOST_CONNECTION) {\r\n        state.status = CONNECTION_STATUS.DISCONNECTED\r\n        elements.statusText.textContent = CONNECTION_STATUS_LABELS[state.status]\r\n        elements.status.dataset.status = state.status\r\n\r\n        elements.disconnect.classList.add('btc-hidden')\r\n        elements.reconnect.classList.add('btc-hidden')\r\n        elements.connect.classList.remove('btc-hidden')\r\n      }\r\n    }, 2000)\r\n\r\n    if (_app__WEBPACK_IMPORTED_MODULE_0__.settings.autoConnect\r\n      && !state.lastConnectionAttemptInterval) {\r\n      tryServerConnect(state.lastConnectionAttemptCount)\r\n      elements.disconnect.classList.remove('btc-hidden')\r\n      elements.reconnect.classList.add('btc-hidden')\r\n      elements.connect.classList.add('btc-hidden')\r\n    }\r\n  })\r\n  scope.$on('BTCServerStatus', (e, data) => {\r\n    if (data === 'connected') {\r\n      console.log('connected')\r\n      state.status = CONNECTION_STATUS.CONNECTED\r\n      elements.statusText.textContent = CONNECTION_STATUS_LABELS[state.status]\r\n      elements.status.dataset.status = state.status\r\n\r\n      clearTimeout(state.lastConnectionAttemptInterval)\r\n      state.lastConnectionAttemptTime = null\r\n      state.lastConnectionAttemptInterval = null\r\n      state.lastConnectionAttemptCount = 0\r\n\r\n      elements.disconnect.classList.remove('btc-hidden')\r\n      elements.reconnect.classList.remove('btc-hidden')\r\n      elements.connect.classList.add('btc-hidden')\r\n    }\r\n    else if (data === 'disconnected') {\r\n      console.log('disconnected')\r\n      state.status = CONNECTION_STATUS.DISCONNECTED\r\n      elements.statusText.textContent = CONNECTION_STATUS_LABELS[state.status]\r\n      elements.status.dataset.status = state.status\r\n\r\n      clearTimeout(state.lastConnectionAttemptInterval)\r\n      state.lastConnectionAttemptTime = null\r\n      state.lastConnectionAttemptInterval = null\r\n      state.lastConnectionAttemptCount = 0\r\n\r\n      elements.disconnect.classList.add('btc-hidden')\r\n      elements.reconnect.classList.add('btc-hidden')\r\n      elements.connect.classList.remove('btc-hidden')\r\n    }\r\n  })\r\n  scope.$on('BTCServerResponse', (e, data) => {\r\n    let dataString = data\r\n    dataString = dataString.substring(1, dataString.lastIndexOf('}') + 1).replace(/\\\\\"/g, '\"')\r\n    //console.dir(JSON.parse(dataString))\r\n    debugEl.textContent = dataString\r\n  })\r\n  scope.$on('BTCUpdateCombo', (e, data) => {\r\n    if (data.combo.current > state.currentCombo) {\r\n      elements.comboInner.classList.remove('btc-combo-add')\r\n      void elements.comboInner.offsetWidth\r\n      elements.comboInner.classList.add('btc-combo-add')\r\n    }\r\n    state.currentCombo = data.combo.current\r\n    elements.comboLevel.innerText = data.combo.level\r\n    elements.comboHighest.innerText = data.combo.highest\r\n    elements.comboInner.dataset.effectCount = data.combo.current\r\n    if (data.combo.current < 10) {\r\n      elements.comboOnes.classList.add('btc-combo-hidden')\r\n      elements.comboTens.classList.add('btc-combo-hidden')\r\n      elements.comboHund.innerText = data.combo.current\r\n    }\r\n    else if (data.combo.current < 100) {\r\n      elements.comboOnes.classList.add('btc-combo-hidden')\r\n      elements.comboTens.classList.remove('btc-combo-hidden')\r\n      elements.comboHund.innerText = Math.floor(data.combo.current / 10)\r\n      elements.comboTens.innerText = data.combo.current % 10\r\n    }\r\n    else if (data.combo.current < 1000) {\r\n      elements.comboOnes.classList.remove('btc-combo-hidden')\r\n      elements.comboTens.classList.remove('btc-combo-hidden')\r\n      elements.comboHund.innerText = Math.floor(data.combo.current / 100)\r\n      elements.comboTens.innerText = Math.floor((data.combo.current % 100) / 10)\r\n      elements.comboOnes.innerText = data.combo.current % 10\r\n    }\r\n    else {\r\n      elements.comboOnes.classList.remove('btc-combo-hidden')\r\n      elements.comboTens.classList.remove('btc-combo-hidden')\r\n      elements.comboHund.innerText = 9\r\n      elements.comboTens.innerText = 9\r\n      elements.comboOnes.innerText = 9\r\n    }\r\n  })\r\n  scope.$on('BTCPrepCommand', (e, data) => {\r\n    //console.debug(data)\r\n    triggerCommandAlert(data)\r\n  })\r\n  scope.$on('BTCTriggerCommand', (e, data) => {\r\n    //console.debug(data)\r\n  })\r\n  scope.$on('BTCDebug-DATA', (e, data) => {\r\n    console.debug(data)\r\n  })\r\n  scope.$on('BTCPingUI', () => {\r\n    bngApi.engineLua(`freeroam_beamTwitchChaos.pongUI()`)\r\n  })\r\n\r\n  scope.$on('BTCVehicleCountdown', (e, data) => {\r\n    if (data <= 0) {\r\n      elements.vehicleLoadText.classList.add('btc-hidden')\r\n    }\r\n    else {\r\n      elements.vehicleLoadText.classList.remove('btc-hidden')\r\n      const countdownTime = Math.floor(data)\r\n\r\n      if (countdownTime === 0) {\r\n        elements.vehicleLoadText.innerText = 'Vehicle load checking now (may cause lag)'\r\n      }\r\n      else {\r\n        elements.vehicleLoadText.innerText = `Vehicle load check in: ${countdownTime} (may cause lag)`\r\n      }\r\n    }\r\n  })\r\n\r\n  elements.disconnect.addEventListener('click', () => {\r\n    elements.disconnect.classList.add('btc-hidden')\r\n    elements.reconnect.classList.remove('btc-hidden')\r\n    elements.connect.classList.remove('btc-hidden')\r\n\r\n    bngApi.engineLua(`freeroam_beamTwitchChaos.disconnectToServer()`)\r\n\r\n    if (state.lastConnectionAttemptInterval) {\r\n      clearTimeout(state.lastConnectionAttemptInterval)\r\n      state.lastConnectionAttemptTime = null\r\n      state.lastConnectionAttemptInterval = null\r\n      state.lastConnectionAttemptCount = 0\r\n    }\r\n  })\r\n  elements.reconnect.addEventListener('click', () => {\r\n    elements.disconnect.classList.remove('btc-hidden')\r\n    elements.reconnect.classList.remove('btc-hidden')\r\n    elements.connect.classList.add('btc-hidden')\r\n\r\n    bngApi.engineLua(`freeroam_beamTwitchChaos.disconnectToServer()`)\r\n    tryServerConnect(state.lastConnectionAttemptCount, true)\r\n  })\r\n  elements.connect.addEventListener('click', () => {\r\n    elements.disconnect.classList.remove('btc-hidden')\r\n    elements.reconnect.classList.remove('btc-hidden')\r\n    elements.connect.classList.add('btc-hidden')\r\n\r\n    tryServerConnect(state.lastConnectionAttemptCount)\r\n  })\r\n}\n\n//# sourceURL=webpack://beamtwitchchaos/./src/js/connection.js?");

/***/ }),

/***/ "./src/js/index.js":
/*!*************************!*\
  !*** ./src/js/index.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _styles_index_less__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../styles/index.less */ \"./src/styles/index.less\");\n/* harmony import */ var _test__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./test */ \"./src/js/test.js\");\n/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./app */ \"./src/js/app.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nangular.module('beamng.apps')\r\n  .directive('beamTwitchChaos', [() => {\r\n    return {\r\n      templateUrl: '/ui/modules/apps/BeamTwitchChaos/app.html',\r\n      replace: true,\r\n      restrict: 'EA',\r\n      link: (scope, element,) => {\r\n        scope.app = (0,_app__WEBPACK_IMPORTED_MODULE_2__.app)(scope, element)\r\n\r\n        scope.settings = {\r\n          autoConnect: true,\r\n        }\r\n\r\n        scope.buttons = []\r\n        scope.menus = {}\r\n        scope.currentMenu = null\r\n        scope.commandList = {}\r\n\r\n        scope.initialize = () => {\r\n          const menuButtons = scope.rootElement.querySelectorAll('.btc-menu-button')\r\n          const menus = scope.rootElement.querySelectorAll('.btc-menu')\r\n          menus.forEach(menu => {\r\n            scope.menus[menu.dataset.loc] = {\r\n              ele: menu,\r\n              loc: menu.dataset.loc,\r\n              state: menu.classList.contains('btc-open') ? 'open' : 'closed',\r\n            }\r\n\r\n            if (menu.classList.contains('btc-open') && !scope.currentMenu) {\r\n              scope.currentMenu = menu.dataset.loc\r\n            }\r\n            else {\r\n              (0,_test__WEBPACK_IMPORTED_MODULE_1__.toggleMenu)(scope.menus[menu.dataset.loc])\r\n            }\r\n          })\r\n          menuButtons.forEach(button => {\r\n            scope.buttons.push({\r\n              ele: button,\r\n              loc: button.dataset.loc,\r\n            })\r\n\r\n            button.addEventListener('click', () => {\r\n              ;(0,_test__WEBPACK_IMPORTED_MODULE_1__.toggleMenu)(scope.menus[scope.currentMenu])\r\n              ;(0,_test__WEBPACK_IMPORTED_MODULE_1__.toggleMenu)(scope.menus[button.dataset.loc], 'open')\r\n              scope.currentMenu = button.dataset.loc\r\n            })\r\n          })\r\n        }\r\n        scope.initialize()\r\n      }\r\n    };\r\n  }]);\r\n\r\nconst commands = {\r\n  pop: {\r\n    name: 'Pop',\r\n    desc: 'Pops tires and breaks wheels',\r\n    bitsDefault: 20,\r\n    funcCall: 'pop',\r\n  },\r\n  color: {\r\n    name: 'Color',\r\n    desc: 'Changes a part, or a random part, to a color, or a random color, or the entire car',\r\n    bitsDefault: 50,\r\n    funcCall: 'color',\r\n    settings: [\r\n      {\r\n        name: 'Part Control',\r\n        desc: 'If chat can specify a part or not',\r\n        type: Boolean,\r\n        default: true,\r\n      }\r\n    ],\r\n    options: [\r\n      {\r\n        name: 'Color',\r\n        desc: 'The color to change to. If not included, uses a random color',\r\n        type: String,\r\n        validation: 'pattern',\r\n        pattern: /#[0-9a-f]{1,6}/g,\r\n        missing: () => {\r\n          const r = Math.floor(Math.random() * 255).toString(16)\r\n          const g = Math.floor(Math.random() * 255).toString(16)\r\n          const b = Math.floor(Math.random() * 255).toString(16)\r\n\r\n          return `#${r}${g}${b}`\r\n        }\r\n      },\r\n      {\r\n        name: 'Part',\r\n        desc: 'The part to apply the color to, if enabled',\r\n        type: String,\r\n        validation: 'match',\r\n        match: ['hood', 'door', 'trunk'],\r\n        missing: () => {\r\n          return commands.color.options[2].match[Math.floor(Math.random() * commands.color.options[2].match.length)]\r\n        }\r\n      }\r\n    ]\r\n  }\r\n}\n\n//# sourceURL=webpack://beamtwitchchaos/./src/js/index.js?");

/***/ }),

/***/ "./src/js/test.js":
/*!************************!*\
  !*** ./src/js/test.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toggleMenu: () => (/* binding */ toggleMenu)\n/* harmony export */ });\n\r\nconst toggleMenu = (menu, state = 'closed') => {\r\n  if (state === 'closed') {\r\n    menu.ele.classList.add('btc-closed')\r\n    menu.ele.classList.remove('btc-open')\r\n  }\r\n  else if (state === 'open') {\r\n    menu.ele.classList.remove('btc-closed')\r\n    menu.ele.classList.add('btc-open')\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://beamtwitchchaos/./src/js/test.js?");

/***/ }),

/***/ "./src/js/ui-effects.js":
/*!******************************!*\
  !*** ./src/js/ui-effects.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addCCEffect: () => (/* binding */ addCCEffect),\n/* harmony export */   initialize: () => (/* binding */ initialize)\n/* harmony export */ });\nlet alertContainer\r\nlet effectContainer\r\nlet copyContainer\r\nlet blackoutContainer\r\nlet buttonContainer\r\n\r\nlet comboCountContainer\r\nlet comboCount\r\nlet comboCountInner\r\nlet levelContainer\r\n\r\nlet canvasEle\r\nlet context\r\nlet drawCanvasEle = new OffscreenCanvas(256, 256)\r\nlet drawContext = drawCanvasEle.getContext('2d')\r\n\r\nconst windowSize = {\r\n  w: 0,\r\n  h: 0,\r\n}\r\nconst visualBounds = {\r\n  xMin: 0,\r\n  xMax: 0,\r\n  yMin: 0,\r\n  yMax: 0,\r\n}\r\n\r\nconst dvdSize = {\r\n  w: 210,\r\n  h: 107,\r\n}\r\nconst rainbow = [\r\n  'rgb(255, 51,  51)',\r\n  'rgb(255, 102,  51)',\r\n  'rgb(255, 204, 51)',\r\n  'rgb(51,  255, 51)',\r\n  'rgb(51,  51,  255)',\r\n  'rgb(102, 51,  255)',\r\n  'rgb(204, 51,  255)',\r\n]\r\nconst adEnterTypes = [\r\n  'ad-in-slide',\r\n  'ad-in-fade',\r\n]\r\nconst adExitTypes = [\r\n  'ad-out-slide',\r\n  'ad-out-fade',\r\n]\r\nconst adDirections = [\r\n  'ad-left',\r\n  'ad-right',\r\n  'ad-top',\r\n  'ad-bottom',\r\n]\r\nconst imagePatterns = {}\r\n\r\nlet shakePos = {\r\n  x: 0,\r\n  y: 0,\r\n}\r\n\r\nlet frameTime = 0.016\r\nlet drawTime = 0\r\nlet prevDrawTime = 0\r\nlet drawCalls = {}\r\n\r\nlet ccData = {\r\n  status: 'off'\r\n}\r\nlet clippys = {}\r\nlet winErrors = {}\r\n\r\nconst clearCanvas = () => {\r\n  context.clearRect(0, 0, windowSize.w, windowSize.h)\r\n  drawContext.clearRect(0, 0, windowSize.w, windowSize.h)\r\n}\r\n\r\nconst getScaledPosition = (gridPos, objSize) => {\r\n  return {\r\n    x: (gridPos.x / 100) * (windowSize.w - objSize.w),\r\n    y: (gridPos.y / 100) * (windowSize.h - objSize.h),\r\n  }\r\n}\r\n\r\n//#region DVD/Ad functions\r\nconst addDvd = (dvdData) => {\r\n  const drawSize = {\r\n    w: (windowSize.w / 1920) * dvdSize.w,\r\n    h: (windowSize.w / 1920) * dvdSize.h,\r\n  }\r\n  const drawPos = {\r\n    x: (Math.random() * (visualBounds.xMax - visualBounds.xMin - drawSize.w) + visualBounds.xMin),\r\n    y: (Math.random() * (visualBounds.yMax - visualBounds.yMin - drawSize.h) + visualBounds.yMin),\r\n  }\r\n\r\n  const newDvdImage = copyContainer.querySelector(\".btc-dvd-logo\").cloneNode(true)\r\n  newDvdImage.classList.add('btc-image-effect')\r\n  newDvdImage.dataset.effectId = dvdData.id\r\n  newDvdImage.dataset.level = dvdData.level || 0\r\n  newDvdImage.dataset.lifeLeft = dvdData.lifeLeft\r\n  const dir = Math.random() * Math.PI * 2\r\n  newDvdImage.dataset.xDir = dvdData.xDir || Math.sin(dir)\r\n  newDvdImage.dataset.yDir = dvdData.yDir || Math.cos(dir)\r\n  newDvdImage.dataset.xPos = drawPos.x\r\n  newDvdImage.dataset.yPos = drawPos.y\r\n  newDvdImage.dataset.cloned = dvdData.cloned || 'false'\r\n  newDvdImage.dataset.type = 'dvd'\r\n  newDvdImage.style.left = `${drawPos.x}px`\r\n  newDvdImage.style.top = `${drawPos.y}px`\r\n  newDvdImage.style.width = `${drawSize.w}px`\r\n  newDvdImage.style.height = `${drawSize.h}px`\r\n  newDvdImage.style.fill = rainbow[Math.floor(Math.random() * rainbow.length)]\r\n  effectContainer.append(newDvdImage)\r\n}\r\n\r\nconst addAd = (adData) => {\r\n  const newAdNum = Math.ceil(Math.random() * 14)\r\n  const newAd = copyContainer.querySelector(`.btc-ad-${newAdNum}`).cloneNode(true)\r\n  const drawSize = {\r\n    w: Number.parseInt(newAd.dataset.setWidth) || ((Number.parseInt(newAd.dataset.minWidth) || 200) + Math.random() * ((Number.parseInt(newAd.dataset.maxWidth) || 600) - (Number.parseInt(newAd.dataset.minWidth) || 200))),\r\n    h: Number.parseInt(newAd.dataset.setHeight) || ((Number.parseInt(newAd.dataset.minHeight) || 200) + Math.random() * ((Number.parseInt(newAd.dataset.maxHeight) || 600) - (Number.parseInt(newAd.dataset.minHeight) || 200))),\r\n  }\r\n\r\n  const inOutTime = Math.floor(250 + (Math.random() * 750))\r\n  const inDelay = Math.floor(Math.random() * 2000)\r\n  newAd.dataset.effectId = adData.id\r\n  newAd.dataset.inOutTime = inOutTime\r\n  newAd.dataset.inDelay = inDelay\r\n  newAd.dataset.lifeLeft = adData.lifeLeft + (inOutTime / 1000) + (inDelay / 1000)\r\n  newAd.dataset.maxLife = adData.lifeLeft + (inOutTime / 1000)\r\n  newAd.dataset.type = 'ad'\r\n  newAd.style.width = `${drawSize.w}px`\r\n  newAd.style.height = `${drawSize.h}px`\r\n  newAd.style.transition = `all ${inOutTime}ms`\r\n  effectContainer.append(newAd)\r\n\r\n  switch (newAd.dataset.adType) {\r\n    default:\r\n    case 'standard':\r\n      const drawPos = {\r\n        x: (Math.random() * (visualBounds.xMax - visualBounds.xMin - newAd.clientHeight) + visualBounds.xMin),\r\n        y: (Math.random() * (visualBounds.yMax - visualBounds.yMin - newAd.clientWidth) + visualBounds.yMin),\r\n      }\r\n      const enterType = adEnterTypes[Math.floor(Math.random() * adEnterTypes.length)]\r\n      const exitType = adExitTypes[Math.floor(Math.random() * adExitTypes.length)]\r\n      const direction = adDirections[Math.floor(Math.random() * adDirections.length)]\r\n\r\n      newAd.classList.add('btc-hidden', 'ad-in-out', enterType, exitType, direction)\r\n      newAd.dataset.xPos = drawPos.x\r\n      newAd.dataset.yPos = drawPos.y\r\n      newAd.style.left = `${drawPos.x}px`\r\n      newAd.style.top = `${drawPos.y}px`\r\n      newAd.querySelectorAll('button').forEach((button) => {\r\n        button.addEventListener('click', () => {\r\n          const drawSize = {\r\n            w: (Number.parseInt(newAd.dataset.extrawidth) || 0) + 100 + Math.random() * 350,\r\n            h: 200,\r\n          }\r\n          newAd.style.width = `${drawSize.w}px`\r\n          const drawPos = {\r\n            x: (Math.random() * (visualBounds.xMax - visualBounds.xMin - newAd.clientHeight) + visualBounds.xMin),\r\n            y: (Math.random() * (visualBounds.yMax - visualBounds.yMin - newAd.clientWidth) + visualBounds.yMin),\r\n          }\r\n          newAd.dataset.xPos = drawPos.x\r\n          newAd.dataset.yPos = drawPos.y\r\n          newAd.style.left = `${drawPos.x}px`\r\n          newAd.style.top = `${drawPos.y}px`\r\n        })\r\n      })\r\n      break\r\n    case 'banner':\r\n  }\r\n}\r\n\r\nconst drawDvd = (ele, dt) => {\r\n  const drawSize = {\r\n    w: (windowSize.w / 1920) * dvdSize.w,\r\n    h: (windowSize.w / 1920) * dvdSize.h,\r\n  }\r\n  const drawPos = {\r\n    x: Math.min(visualBounds.xMax - drawSize.w, Math.max(visualBounds.xMin, Number.parseFloat(ele.dataset.xPos))),\r\n    y: Math.min(visualBounds.yMax - drawSize.h, Math.max(visualBounds.yMin, Number.parseFloat(ele.dataset.yPos))),\r\n  }\r\n\r\n  drawPos.x = drawPos.x + (Number.parseFloat(ele.dataset.xDir) * dt * 1200)\r\n  drawPos.y = drawPos.y + (Number.parseFloat(ele.dataset.yDir) * dt * 1200)\r\n\r\n  if (drawPos.x < visualBounds.xMin || drawPos.x > visualBounds.xMax - drawSize.w) {\r\n    drawPos.x = Math.min(visualBounds.xMax, Math.max(visualBounds.xMin, drawPos.x - (Number.parseFloat(ele.dataset.xDir) * dt * 155)))\r\n    ele.dataset.xDir = -Number.parseFloat(ele.dataset.xDir)\r\n    ele.style.fill = rainbow[(Math.floor(Math.random() * (rainbow.length)))]\r\n  }\r\n  if (drawPos.y < visualBounds.yMin || drawPos.y > visualBounds.yMax - drawSize.h) {\r\n    drawPos.y = Math.min(visualBounds.yMax, Math.max(visualBounds.yMin, drawPos.y - (Number.parseFloat(ele.dataset.yDir) * dt * 155)))\r\n    ele.dataset.yDir = -Number.parseFloat(ele.dataset.yDir)\r\n    ele.style.fill = rainbow[(Math.floor(Math.random() * (rainbow.length)))]\r\n  }\r\n\r\n  if (ele.dataset.cloned !== 'true') {\r\n    if (drawPos.x < visualBounds.xMin + 5 || drawPos.x > visualBounds.xMax - drawSize.w - 5) {\r\n      if (drawPos.y < visualBounds.yMin + 5 || drawPos.y > visualBounds.yMax - drawSize.h - 5) {\r\n        for (let i = 0; i <= Number.parseFloat(ele.dataset.level); i++) {\r\n          const dir = Math.random() * Math.PI * 2\r\n          addDvd({\r\n            x: drawPos.x + ((Math.random() * 10) - 5),\r\n            y: drawPos.y + ((Math.random() * 10) - 5),\r\n            xDir: Math.sin(dir),\r\n            yDir: Math.cos(dir),\r\n            id: ele.dataset.effectId,\r\n            maxLife: ele.dataset.life,\r\n            life: 0,\r\n            level: Number.parseFloat(ele.dataset.level) + 1,\r\n            cloned: 'true'\r\n          })\r\n        }\r\n        ele.dataset.cloned = 'true'\r\n      }\r\n    }\r\n  }\r\n\r\n  ele.dataset.xPos = drawPos.x\r\n  ele.dataset.yPos = drawPos.y\r\n  ele.style.left = `${drawPos.x}px`\r\n  ele.style.top = `${drawPos.y}px`\r\n  ele.dataset.lifeLeft = Number.parseFloat(ele.dataset.lifeLeft - dt)\r\n}\r\n\r\nconst drawAd = (ele, dt) => {\r\n  const drawPos = {\r\n    x: Math.min(visualBounds.xMax - ele.clientWidth, Math.max(visualBounds.xMin, Number.parseFloat(ele.dataset.xPos))),\r\n    y: Math.min(visualBounds.yMax - ele.clientHeight, Math.max(visualBounds.yMin, Number.parseFloat(ele.dataset.yPos))),\r\n  }\r\n  ele.dataset.lifeLeft = Number.parseFloat(ele.dataset.lifeLeft) - dt\r\n\r\n  ele.dataset.xPos = drawPos.x\r\n  ele.dataset.yPos = drawPos.y\r\n  ele.style.left = `${drawPos.x}px`\r\n  ele.style.top = `${drawPos.y}px`\r\n\r\n  if (Number.parseFloat(ele.dataset.lifeLeft) < Number.parseFloat(ele.dataset.inOutTime) / 1000) {\r\n    ele.classList.add('ad-in-out')\r\n  }\r\n  else if (Number.parseFloat(ele.dataset.lifeLeft) < Number.parseFloat(ele.dataset.maxLife) - Number.parseFloat(ele.dataset.inOutTime) / 1000) {\r\n    ele.classList.remove('ad-in-out')\r\n  }\r\n  else if (Number.parseFloat(ele.dataset.lifeLeft) < Number.parseFloat(ele.dataset.maxLife)) {\r\n    ele.classList.remove('btc-hidden')\r\n  }\r\n\r\n  const title = ele.querySelector('.btc-ad-flash')\r\n  if (title) {\r\n    if (Math.floor(Number.parseFloat(ele.dataset.lifeLeft) * 4 % 2) == 0) {\r\n      title.style.color = title.dataset.offcolor || 'red'\r\n    }\r\n    else {\r\n      title.style.color = title.dataset.oncolor || 'blue'\r\n    }\r\n  }\r\n}\r\n//#endregion\r\n\r\nconst shakeElement = (ele, shakeLevel) => {\r\n  const currentShakeOffset = {\r\n    x: ele.style.left.substring(0, -2),\r\n    y: ele.style.top.substring(0, -2),\r\n  }\r\n\r\n  const shakeOffset = {\r\n    x: (currentShakeOffset.x / 1.2) + ((Math.random() - 0.5) * shakeLevel),\r\n    y: (currentShakeOffset.y / 1.2) + ((Math.random() - 0.5) * shakeLevel),\r\n  }\r\n\r\n  ele.style.left = `${shakeOffset.x}px`\r\n  ele.style.top = `${shakeOffset.y}px`\r\n}\r\n\r\nconst drawClassicWindow = (options) => {\r\n  const { x, y, width, height, bezel = 5 } = {...options}\r\n  drawContext.globalAlpha = 1\r\n  drawContext.fillStyle = '#AAA'\r\n  drawContext.fillRect(x, y, width, height)\r\n  drawContext.fillStyle = '#DDD'\r\n  drawContext.beginPath()\r\n  drawContext.moveTo(x, y)\r\n  drawContext.lineTo(x + width, y)\r\n  drawContext.lineTo(x, y + height)\r\n  drawContext.closePath()\r\n  drawContext.fill()\r\n  drawContext.fillStyle = '#CCC'\r\n  drawContext.fillRect(x + bezel, y + bezel, width - (bezel * 2), height - (bezel * 2))\r\n}\r\n\r\n//#region Total Control Functions\r\nconst drawTVBorder = () => {\r\n  drawContext.globalAlpha = 1\r\n  // Top\r\n  let tvGradient = drawContext.createRadialGradient(windowSize.w / 2, windowSize.h * 5, windowSize.h * 74 / 15, \r\n    windowSize.w / 2, windowSize.h * 5, windowSize.h * 498 / 100)\r\n  tvGradient.addColorStop(0.7, \"rgba(0, 0, 0, 0)\")\r\n  tvGradient.addColorStop(1, \"rgba(0, 0, 0, 1)\")\r\n  drawContext.fillStyle = tvGradient\r\n  drawContext.fillRect(0, 0, windowSize.w, windowSize.h)\r\n  // Left\r\n  tvGradient = drawContext.createRadialGradient(windowSize.w * -4, windowSize.h / 2, windowSize.w * 74 / 15, \r\n    windowSize.w * -4, windowSize.h / 2, windowSize.w * 498 / 100)\r\n  tvGradient.addColorStop(0.5, \"rgba(0, 0, 0, 0)\")\r\n  tvGradient.addColorStop(1, \"rgba(0, 0, 0, 1)\")\r\n  drawContext.fillStyle = tvGradient\r\n  drawContext.fillRect(0, 0, windowSize.w, windowSize.h)\r\n  // Bottom\r\n  tvGradient = drawContext.createRadialGradient(windowSize.w / 2, windowSize.h * -4, windowSize.h * 74 / 15, \r\n    windowSize.w / 2, windowSize.h * -4, windowSize.h * 498 / 100)\r\n  tvGradient.addColorStop(0.7, \"rgba(0, 0, 0, 0)\")\r\n  tvGradient.addColorStop(1, \"rgba(0, 0, 0, 1)\")\r\n  drawContext.fillStyle = tvGradient\r\n  drawContext.fillRect(0, 0, windowSize.w, windowSize.h)\r\n  // Right\r\n  tvGradient = drawContext.createRadialGradient(windowSize.w * 5, windowSize.h / 2, windowSize.w * 74 / 15, \r\n    windowSize.w * 5, windowSize.h / 2, windowSize.w * 498 / 100)\r\n  tvGradient.addColorStop(0.5, \"rgba(0, 0, 0, 0)\")\r\n  tvGradient.addColorStop(1, \"rgba(0, 0, 0, 1)\")\r\n  drawContext.fillStyle = tvGradient\r\n  drawContext.fillRect(0, 0, windowSize.w, windowSize.h)\r\n}\r\n\r\nconst drawTVPowerOff = (t) => {\r\n  let offTightness = 2.75\r\n  let xOffset = windowSize.w / 2 * offTightness * (t - 0.6)\r\n  let yOffset = windowSize.h / 2 * offTightness * (t - 0.6)\r\n  drawContext.globalAlpha = Math.min(1, Math.max(0, (t - 0.7) * 6))\r\n  drawContext.fillStyle = `rgb(${t * 255}, ${t * 255}, ${t * 255})`\r\n  drawContext.fillRect(0, 0, windowSize.w, windowSize.h)\r\n  drawContext.globalAlpha = 1\r\n  drawContext.fillStyle = \"#000\"\r\n  // TL\r\n  drawContext.beginPath()\r\n  drawContext.moveTo(0, 0)\r\n  drawContext.lineTo(windowSize.w / 2, 0)\r\n  drawContext.bezierCurveTo(windowSize.w / 2, yOffset, \r\n  xOffset, windowSize.h / 2, \r\n                            0, windowSize.h / 2)\r\n  drawContext.closePath()\r\n  drawContext.fill()\r\n  // TR\r\n  drawContext.beginPath()\r\n  drawContext.moveTo(windowSize.w, 0)\r\n  drawContext.lineTo(windowSize.w / 2, 0)\r\n  drawContext.bezierCurveTo(windowSize.w / 2, yOffset, \r\n  windowSize.w - xOffset, windowSize.h / 2, \r\n                            windowSize.w, windowSize.h / 2)\r\n  drawContext.closePath()\r\n  drawContext.fill()\r\n  // BL\r\n  drawContext.beginPath()\r\n  drawContext.moveTo(0, windowSize.h)\r\n  drawContext.lineTo(windowSize.w / 2, windowSize.h)\r\n  drawContext.bezierCurveTo(windowSize.w / 2, windowSize.h - yOffset, \r\n  xOffset, windowSize.h / 2, \r\n                            0, windowSize.h / 2)\r\n  drawContext.closePath()\r\n  drawContext.fill()\r\n  // BR\r\n  drawContext.beginPath()\r\n  drawContext.moveTo(windowSize.w, windowSize.h)\r\n  drawContext.lineTo(windowSize.w / 2, windowSize.h)\r\n  drawContext.bezierCurveTo(windowSize.w / 2, windowSize.h - yOffset, \r\n  windowSize.w - xOffset, windowSize.h / 2, \r\n                            windowSize.w, windowSize.h / 2)\r\n  drawContext.closePath()\r\n  drawContext.fill()\r\n}\r\n\r\nconst drawTVEffects = (time, staticAlpha = 0.05) => {\r\n  drawContext.globalAlpha = Math.min(0.3, Math.max(0.8, staticAlpha))\r\n  drawContext.fillStyle = '#5A8'\r\n  drawContext.fillRect(0, 0, windowSize.w, windowSize.h)\r\n  let staticColor = 0\r\n  let windowMod = {\r\n    x: Math.ceil(windowSize.w / 64),\r\n    y: Math.ceil(windowSize.h / 64),\r\n  }\r\n  let scanLineMod = 4\r\n  let scanLineSpeed = 0.002\r\n  let scanLineWidthMod = 2\r\n  for (let i = 0; i < windowMod.y * scanLineMod; i++) {\r\n    staticColor = 10 + (Math.sin((i / scanLineWidthMod) + (time * scanLineSpeed) % (Math.PI * 2)) + 1) / 2 * 90\r\n    drawContext.fillStyle = `hsl(${(i * 120) % 360}deg, ${staticColor / 3}%, ${staticColor}%)`\r\n    drawContext.fillRect(0, windowSize.h / (windowMod.y * scanLineMod) * i, windowSize.w, windowSize.h / (windowMod.y * scanLineMod))\r\n  }\r\n  drawContext.globalAlpha = staticAlpha\r\n  for (let i = 0; i < windowMod.x; i++) {\r\n    for (let j = 0; j < windowMod.y; j++) {\r\n      staticColor = 105 + Math.floor(Math.random() * 150)\r\n      drawContext.fillStyle = `rgb(${staticColor}, ${staticColor}, ${staticColor})`\r\n      drawContext.fillRect(windowSize.w / windowMod.x * i, windowSize.h / windowMod.y * j,\r\n        windowSize.w / windowMod.x, windowSize.h / windowMod.y)\r\n    }\r\n  }\r\n}\r\n\r\nlet ccEffectList = []\r\nconst clearCCEffectList = () => {\r\n  ccEffectList = []\r\n}\r\n\r\nconst addCCEffect = (commandData) => {\r\n  let codeParsed = 'unknown'\r\n\r\n  switch(commandData.code) {\r\n    case 'cc_throttle.0':\r\n      codeParsed = 'throttle 0%'\r\n      break;\r\n    case 'cc_throttle.1':\r\n      codeParsed = 'throttle 50%'\r\n      break;\r\n    case 'cc_throttle.2':\r\n      codeParsed = 'throttle 100%'\r\n      break;\r\n    case 'cc_straight':\r\n      codeParsed = 'steer 0deg'\r\n      break;\r\n    case 'cc_left.1':\r\n      codeParsed = 'steer -15deg'\r\n      break;\r\n    case 'cc_left.2':\r\n      codeParsed = 'steer -30deg'\r\n      break;\r\n    case 'cc_left.3':\r\n      codeParsed = 'steer -45deg'\r\n      break;\r\n    case 'cc_right.1':\r\n      codeParsed = 'steer 15deg'\r\n      break;\r\n    case 'cc_right.2':\r\n      codeParsed = 'steer 30deg'\r\n      break;\r\n    case 'cc_right.3':\r\n      codeParsed = 'steer 45deg'\r\n      break;\r\n    case 'cc_brake.0':\r\n      codeParsed = 'brake 0%'\r\n      break;\r\n    case 'cc_brake.1':\r\n      codeParsed = 'brake 50%'\r\n      break;\r\n    case 'cc_brake.2':\r\n      codeParsed = 'brake 100%'\r\n      break;\r\n    case 'cc_gear.up':\r\n      codeParsed = 'gear up'\r\n      break;\r\n    case 'cc_gear.down':\r\n      codeParsed = 'gear down'\r\n      break;\r\n    case 'cc_gear.neutral':\r\n      codeParsed = 'gear N'\r\n      break;\r\n    case 'cc_gear.reverse':\r\n      codeParsed = 'gear R'\r\n      break;\r\n  }\r\n\r\n  ccEffectList.push({\r\n    user: commandData.viewer,\r\n    code: codeParsed || commandData.code,\r\n  })\r\n  //console.log(ccEffectList)\r\n}\r\n\r\nconst drawCCStatus = () => {\r\n  const statusXPos = -285\r\n  drawClassicWindow({\r\n    x: windowSize.w + statusXPos, \r\n    y: windowSize.h / 2 - 105,\r\n    width: 210,\r\n    height: 310,\r\n  })\r\n  drawContext.globalAlpha = 1\r\n  drawContext.fillStyle = '#00A'\r\n  drawContext.fillRect(windowSize.w + statusXPos + 5, windowSize.h / 2 - 100, 200, 25)\r\n  drawContext.fillStyle = '#FFF'\r\n  drawContext.textAlign = 'left'\r\n  drawContext.font = \"14pt Windows95, 'Noto Sans', 'Noto Sans JP', 'Noto Sans KR', 'Noto Sans SC', sans-serif\"\r\n  drawContext.fillText('TOTAL CONTROL', windowSize.w + statusXPos + 10, windowSize.h / 2 - 80)\r\n  drawContext.font = \"12pt Windows95, 'Noto Sans', 'Noto Sans JP', 'Noto Sans KR', 'Noto Sans SC', sans-serif\"\r\n  drawContext.fillStyle = '#000'\r\n  drawContext.fillText('TIME LEFT', windowSize.w + statusXPos + 10, windowSize.h / 2 - 35)\r\n  drawContext.fillText('STEER', windowSize.w + statusXPos + 10, windowSize.h / 2 + 5)\r\n  drawContext.fillText('THROTTLE', windowSize.w + statusXPos + 10, windowSize.h / 2 + 35)\r\n  drawContext.fillText('BRAKE', windowSize.w + statusXPos + 10, windowSize.h / 2 + 65)\r\n  drawContext.textAlign = 'right'\r\n  drawContext.font = \"bold 30pt Windows95, 'Noto Sans', 'Noto Sans JP', 'Noto Sans KR', 'Noto Sans SC', sans-serif\"\r\n  drawContext.fillText((ccData.countdown || 0).toPrecision(3), windowSize.w + statusXPos + 200, windowSize.h / 2 - 35)\r\n  drawContext.fillStyle = '#E0E0E0'\r\n  drawContext.strokeStyle = '#BBB'\r\n  drawContext.lineWidth = 1.5\r\n  drawContext.fillRect(windowSize.w + statusXPos + 10, windowSize.h / 2 - 20, 190, 2)\r\n  drawContext.fillRect(windowSize.w + statusXPos + 10, windowSize.h / 2 + 83, 190, 110)\r\n  drawContext.strokeRect(windowSize.w + statusXPos + 10, windowSize.h / 2 + 83, 190, 110)\r\n  drawContext.fillRect(windowSize.w + statusXPos + 100, windowSize.h / 2 - 12, 100, 20)\r\n  drawContext.strokeRect(windowSize.w + statusXPos + 100, windowSize.h / 2 - 12, 100, 20)\r\n  drawContext.fillRect(windowSize.w + statusXPos + 100, windowSize.h / 2 + 18, 100, 20)\r\n  drawContext.strokeRect(windowSize.w + statusXPos + 100, windowSize.h / 2 + 18, 100, 20)\r\n  drawContext.fillRect(windowSize.w + statusXPos + 100, windowSize.h / 2 + 48, 100, 20)\r\n  drawContext.strokeRect(windowSize.w + statusXPos + 100, windowSize.h / 2 + 48, 100, 20)\r\n  drawContext.fillStyle = '#C4C4C4'\r\n  drawContext.fillRect(windowSize.w + statusXPos + 180, windowSize.h / 2 + 83, 20, 110)\r\n  drawClassicWindow({\r\n    x: windowSize.w + statusXPos + 180, \r\n    y: windowSize.h / 2 + 88,\r\n    width: 20,\r\n    height: 20,\r\n    bezel: 3,\r\n  })\r\n  \r\n  if (ccData.inputs) {\r\n    // Steer bar graph\r\n    drawContext.fillStyle = '#00A'\r\n    drawContext.fillRect(windowSize.w  + statusXPos + 150, windowSize.h / 2 - 10, ccData.inputs.steering.amount * 48, 17)\r\n    // Throttle bar graph\r\n    drawContext.fillStyle = '#0A0'\r\n    drawContext.fillRect(windowSize.w  + statusXPos + 99, windowSize.h / 2 + 20, ccData.inputs.throttle.amount * 99, 17)\r\n    // Brake bar graph\r\n    drawContext.fillStyle = '#A00'\r\n    drawContext.fillRect(windowSize.w  + statusXPos + 99, windowSize.h / 2 + 50, ccData.inputs.brake.amount * 99, 17)\r\n  }\r\n  drawContext.fillStyle = '#C4C4C4'\r\n  drawContext.fillRect(windowSize.w  + statusXPos + 149, windowSize.h / 2 - 12, 2, 20)\r\n\r\n  drawContext.fillStyle = '#000'\r\n  drawContext.font = \"12pt Windows95, 'Noto Sans', 'Noto Sans JP', 'Noto Sans KR', 'Noto Sans SC', sans-serif\"\r\n  for (let i = 0; i < Math.min(7, ccEffectList.length); i++) {\r\n    drawContext.textAlign = 'left'\r\n    drawContext.fillText(`${ccEffectList[ccEffectList.length - i - 1].user}:`, windowSize.w  + statusXPos + 15, windowSize.h / 2 + 100 + (i * 15), 80)\r\n    drawContext.textAlign = 'right'\r\n    drawContext.fillText(`${ccEffectList[ccEffectList.length - i - 1].code}`, windowSize.w  + statusXPos + 175, windowSize.h / 2 + 100 + (i * 15))\r\n  }\r\n}\r\n//#endregion\r\n\r\n//#region Clippy Functions\r\nconst drawClippy = (clippyInfo) => {\r\n  const { position, lifeLeft, popInTime, type } = clippyInfo\r\n  const { x, y } = position\r\n\r\n  drawContext.globalAlpha = 1\r\n  drawContext.fillStyle = imagePatterns.clippyBlank\r\n  drawContext.translate(x, y)\r\n  drawContext.beginPath()\r\n  drawContext.rect(0, 0, 220, 250)\r\n  if (popInTime >= 0) {\r\n    drawContext.globalAlpha = 1 - (popInTime * 2)\r\n    drawContext.fillStyle = imagePatterns.clippyBlank\r\n  } else if (popInTime < -0.5) {\r\n    drawContext.fillStyle = imagePatterns.clippy\r\n  } else {\r\n    drawContext.fillStyle = imagePatterns.clippyBlank\r\n  }\r\n  drawContext.fill()\r\n  drawContext.closePath()\r\n\r\n  if (popInTime < -0.5) {\r\n    let message = 'do something'\r\n    switch (type) {\r\n      case 'steering':\r\n        message = 'change directions'\r\n        break\r\n      case 'throttle':\r\n        message = 'go faster'\r\n        break\r\n      case 'brake':\r\n        message = 'slow down'\r\n        break\r\n      case 'parkingbrake':\r\n        message = 'drift a bit'\r\n        break\r\n      case 'clutch':\r\n        message = 'make noise'\r\n        break\r\n    }\r\n    drawContext.font = \"12pt Windows95, 'Noto Sans', 'Noto Sans JP', 'Noto Sans KR', 'Noto Sans SC', sans-serif\"\r\n    drawContext.fillStyle = '#000'\r\n    drawContext.textAlign = 'left'\r\n    drawContext.fillText('It looks like you\\'re trying to drive', 10, 30)\r\n    drawContext.fillText('but having some trouble. I think', 10, 50)\r\n    drawContext.fillText(`you should ${message}.`, 10, 70)\r\n\r\n    drawContext.strokeStyle = '#000'\r\n    drawContext.beginPath()\r\n    drawContext.lineJoin = 'round'\r\n    drawContext.rect(10, 100, 90, 25)\r\n    drawContext.rect(110, 100, 90, 25)\r\n    drawContext.stroke()\r\n    drawContext.closePath()\r\n    drawContext.textAlign = 'center'\r\n    drawContext.fillText('Ignore', 55, 118)\r\n    drawContext.fillText(`Yes (${Math.ceil(lifeLeft)}sec)`, 155, 118)\r\n  }\r\n\r\n  drawContext.translate(-x, -y)\r\n}\r\n\r\nconst addClippyButtons = (clippyInfo) => {\r\n  const { position, id, copyId } = clippyInfo\r\n  const { x, y } = position\r\n\r\n  const ignoreButton = document.createElement('button')\r\n  ignoreButton.id = `ignore-${id}-${copyId}`\r\n  ignoreButton.style.position = 'absolute'\r\n  ignoreButton.style.left = `${x + 10}px`\r\n  ignoreButton.style.top = `${y + 100}px`\r\n  ignoreButton.style.width = '90px'\r\n  ignoreButton.style.height = '25px'\r\n  ignoreButton.onclick = () => {\r\n    bngApi.engineLua(`freeroam_btcUiCommands.duplicateClippy(${id}, ${copyId + 1})`)\r\n    removeClippyButtons(`${id}-${copyId}`)\r\n  }\r\n\r\n  const agreeButton = document.createElement('button')\r\n  agreeButton.id = `agree-${id}-${copyId}`\r\n  agreeButton.style.position = 'absolute'\r\n  agreeButton.style.left = `${x + 110}px`\r\n  agreeButton.style.top = `${y + 100}px`\r\n  agreeButton.style.width = '90px'\r\n  agreeButton.style.height = '25px'\r\n  agreeButton.onclick = () => {\r\n    bngApi.engineLua(`freeroam_btcUiCommands.triggerClippy(${id}, ${copyId + 1})`)\r\n    clippys[`${id}.${copyId}`].popInTime = 10\r\n    removeClippyButtons(`${id}-${copyId}`)\r\n  }\r\n\r\n  buttonContainer.append(ignoreButton)\r\n  buttonContainer.append(agreeButton)\r\n}\r\n\r\nconst removeClippyButtons = (clippyKey) => {\r\n  const ignoreButton = buttonContainer.querySelector(`button#ignore-${clippyKey}`)\r\n  const agreeButton = buttonContainer.querySelector(`button#agree-${clippyKey}`)\r\n\r\n  if (ignoreButton) \r\n    ignoreButton.remove()\r\n\r\n  if (agreeButton)\r\n    agreeButton.remove()\r\n}\r\n//#endregion\r\n\r\nconst errorWidth = 290\r\nconst errorHeight = 110\r\nconst drawWinError = (errorInfo, dt) => {\r\n  const { isCrashing, boxes, id, velocity, lifeLeft } = errorInfo\r\n\r\n\r\n  const nextPos = {\r\n    x: -1,\r\n    y: -1,\r\n  }\r\n  winErrors[id].boxes = boxes.filter((box) => {\r\n    const { position } = box\r\n    let lastCrashTime = box.crashTime\r\n    if (isCrashing)\r\n      box.crashTime += dt\r\n\r\n    if (box.crashTime > 5) {\r\n      return false\r\n    } else if (box.crashTime > 0.05 && lastCrashTime <= 0.05 && lifeLeft > 0) {\r\n      velocity.y += 15\r\n\r\n      nextPos.x =  position.x + (velocity.x * 0.5)\r\n      nextPos.y =  position.y + (velocity.y * 0.2)\r\n\r\n      if (nextPos.x < 0) {\r\n        nextPos.x = 0\r\n        velocity.x *= -1\r\n      } else if (nextPos.x > windowSize.w - errorWidth) {\r\n        nextPos.x = windowSize.w - errorWidth\r\n        velocity.x *= -1\r\n      }\r\n\r\n      if (nextPos.y > windowSize.h - errorHeight) {\r\n        nextPos.y = windowSize.h - errorHeight\r\n        velocity.y *= -1 * (0.75 + (Math.random() * 0.5))\r\n      }\r\n    }\r\n    drawClassicWindow({\r\n      x: position.x,\r\n      y: position.y,\r\n      width: errorWidth,\r\n      height: errorHeight,\r\n    })\r\n    drawContext.textAlign = 'left'\r\n    drawContext.font = \"14pt Windows95, 'Noto Sans', 'Noto Sans JP', 'Noto Sans KR', 'Noto Sans SC', sans-serif\"\r\n    drawContext.globalAlpha = 1\r\n    drawContext.fillStyle = '#A00'\r\n    drawContext.fillRect(position.x + 5, position.y + 5, errorWidth - 10, 25)\r\n    drawContext.fillStyle = '#FFF'\r\n    drawContext.fillText('CRITICAL ERROR', position.x + 10, position.y + 25)\r\n    drawContext.fillStyle = '#000'\r\n    drawContext.font = \"12pt Windows95, 'Noto Sans', 'Noto Sans JP', 'Noto Sans KR', 'Noto Sans SC', sans-serif\"\r\n    drawContext.fillText('ERROR: An error has occurred in Windows!', position.x + 10, position.y + 47)\r\n    drawContext.fillText('Your computer will restart now.', position.x + 10, position.y + 65)\r\n    drawClassicWindow({\r\n      x: position.x + 210,\r\n      y: position.y + 70,\r\n      width: 70,\r\n      height: 25,\r\n      bezel: 2,\r\n    })\r\n    drawContext.fillStyle = '#AAA'\r\n    drawContext.fillText('Yes', position.x + 232, position.y + 87)\r\n\r\n    return true\r\n  })\r\n  if (nextPos.x !== -1 && nextPos.y !== -1) {\r\n    winErrors[id].boxes[boxes.length] = {\r\n      crashTime: 0,\r\n      position: nextPos,\r\n    }\r\n  }\r\n}\r\n\r\nlet prevRenderTime = 0\r\nconst updateUI = (time) => {\r\n  const dt = frameTime// time - prevDrawTime\r\n  const renderTime = (1000 / (time - prevRenderTime)).toPrecision(4)\r\n  prevRenderTime = time\r\n  drawTime += dt\r\n\r\n  visualBounds.xMin = blackoutContainer.offsetLeft + shakePos.x\r\n  visualBounds.xMax = blackoutContainer.offsetLeft + blackoutContainer.clientWidth + shakePos.x\r\n  visualBounds.yMin = blackoutContainer.offsetTop + shakePos.y\r\n  visualBounds.yMax = blackoutContainer.offsetTop + blackoutContainer.clientHeight + shakePos.y\r\n\r\n  if (prevDrawTime !== time) {\r\n    clearCanvas()\r\n    shakeElement(comboCountInner, (comboCountInner.dataset.effectCount / 10) || 0)\r\n    Array.from(comboCountInner.children).forEach(child => {\r\n      child.style.animationDuration = `${Math.max(3, 20 - (comboCountInner.dataset.effectCount / 5) || 0)}s`\r\n      child.style.fontSize = `${Math.max(100, 100 + (comboCountInner.dataset.effectCount / 5) || 0)}px`\r\n      child.children[0].style.textShadow = `0 0 ${Math.max(2, 2 + ((comboCountInner.dataset.effectCount / 25) || 0))}px black`\r\n    })\r\n\r\n//#region Total Control Draw\r\n    drawContext.font = \"'Noto Sans', 'Noto Sans JP', 'Noto Sans KR', 'Noto Sans SC', sans-serif\"\r\n    drawContext.textAlign = 'center'\r\n    if (ccData.state !== 'off') {\r\n      switch (ccData.state) {\r\n        case 'transition_in':\r\n          if (ccData.countdown > 0.7) {\r\n            drawTVPowerOff(1 - ((ccData.countdown - 0.7) / 0.3))\r\n          } else if (ccData.countdown < 0.3) {\r\n            drawTVEffects(time, 0.05)\r\n            drawTVBorder()\r\n            drawTVPowerOff((ccData.countdown / 0.3))\r\n          } else {\r\n            drawTVPowerOff(1)\r\n          }\r\n          break;\r\n        case 'transition_out':\r\n          if (ccData.countdown > 0.7) {\r\n            drawTVEffects(time, 0.9)\r\n            drawTVBorder()\r\n            drawTVPowerOff(1 - ((ccData.countdown - 0.7) / 0.3))\r\n          } else if (ccData.countdown < 0.3) {\r\n            drawTVPowerOff((ccData.countdown / 0.3))\r\n          } else {\r\n            drawTVPowerOff(1)\r\n          }\r\n          break;\r\n        case 'countdown':\r\n          let warningLoc = {\r\n            x: windowSize.w / 2,\r\n            y: windowSize.h / 4 * 3 - 120,\r\n          }\r\n          let countdownColor = (1 + Math.sin(ccData.countdown * 10)) * 255 / 2\r\n          drawContext.fillStyle = `rgb(255, ${countdownColor}, ${countdownColor})`\r\n          drawContext.strokeStyle = '#000'\r\n          drawContext.lineWidth = '1.25'\r\n          drawContext.setTransform(2, 0, 0, 1, -windowSize.w / 2, 0)\r\n          drawContext.fillText('WARNING', warningLoc.x, warningLoc.y - 50)\r\n          drawContext.strokeText('WARNING', warningLoc.x, warningLoc.y - 50)\r\n          drawContext.setTransform(1.25, 0, 0, 1, -windowSize.w / 8, 0)\r\n          //drawContext.fillStyle = '#FFF'\r\n          drawContext.font = \"bold 24pt 'Noto Sans', 'Noto Sans JP', 'Noto Sans KR', 'Noto Sans SC', sans-serif\"\r\n          drawContext.fillText('THE CROWD IS TAKING CONTROL', warningLoc.x, warningLoc.y)\r\n          drawContext.strokeText('THE CROWD IS TAKING CONTROL', warningLoc.x, warningLoc.y)\r\n          drawContext.font = \"bold 70pt 'Noto Sans', 'Noto Sans JP', 'Noto Sans KR', 'Noto Sans SC', sans-serif\"\r\n          let countdownVal = (ccData.countdown || 0).toPrecision(2)\r\n          countdownColor = 255\r\n          if (ccData.countdown < 1) {\r\n            if (ccData.countdown < 0.5) {\r\n              countdownColor = (1 + Math.sin(ccData.countdown * 15)) * 255 / 2\r\n              countdownVal = (ccData.countdown).toFixed(3)\r\n            } else {\r\n              countdownColor = 0\r\n            }\r\n          }\r\n          drawContext.fillStyle = `rgb(255, ${countdownColor}, ${countdownColor})`\r\n          drawContext.fillText(countdownVal, warningLoc.x, warningLoc.y + 120)\r\n          drawContext.strokeText(countdownVal, warningLoc.x, warningLoc.y + 120)\r\n          drawContext.setTransform(1, 0, 0, 1, 0, 0)\r\n          break;\r\n        case 'active':\r\n          drawCCStatus()\r\n          drawTVEffects(time, Math.min(0.9, Math.max(0.05, (10 - ccData.countdown) / 10)))\r\n          //drawTVEffects(time, 0.05)\r\n          drawTVBorder()\r\n          break;\r\n        default:\r\n      }\r\n      context.drawImage(drawCanvasEle, 0, 0)\r\n    }\r\n    drawContext.clearRect(0, 0, windowSize.w, windowSize.h)\r\n//#endregion\r\n\r\n    const clippyKeys = Object.keys(clippys)\r\n    let lastPopInTime = 0\r\n    clippyKeys.forEach((clippyKey) => {\r\n      if (clippys[clippyKey]) {\r\n        clippys[clippyKey].lifeLeft -= (dt * 10)\r\n        lastPopInTime = clippys[clippyKey].popInTime\r\n        clippys[clippyKey].popInTime -= (dt * 10)\r\n        clippys[clippyKey].lastCheckTime += (dt * 10)\r\n\r\n        if (clippys[clippyKey].lifeLeft < -0.01 || clippys[clippyKey].lastCheckTime > 0.1) {\r\n          removeClippyButtons(`${clippyKey.replace('.', '-')}`)\r\n          delete clippys[clippyKey]\r\n        } else if (clippys[clippyKey].popInTime < 0.5) {\r\n          drawClippy(clippys[clippyKey])\r\n\r\n          if (clippys[clippyKey].popInTime < -0.5 && lastPopInTime >= -0.5) {\r\n            addClippyButtons(clippys[clippyKey])\r\n          }\r\n        }\r\n      }\r\n    })\r\n    context.drawImage(drawCanvasEle, 0, 0)\r\n    drawContext.clearRect(0, 0, windowSize.w, windowSize.h)\r\n    \r\n    const errKeys = Object.keys(winErrors)\r\n    errKeys.forEach((errKey) => {\r\n      if (winErrors[errKey]) {\r\n        winErrors[errKey].lifeLeft -= (dt * 10)\r\n        winErrors[errKey].lastCheckTime += (dt * 10)\r\n        \r\n        drawWinError(winErrors[errKey], (dt * 10))\r\n\r\n        if (winErrors[errKey].boxes.length === 0 || winErrors.lifeLeft < -0.01) {\r\n          delete winErrors[errKey]\r\n        }\r\n      }\r\n    })\r\n    context.drawImage(drawCanvasEle, 0, 0)\r\n    drawContext.clearRect(0, 0, windowSize.w, windowSize.h)\r\n\r\n    const drawnElements = effectContainer.querySelectorAll('[data-effect-id]')\r\n    const drawnKeys = {}\r\n    drawnElements.forEach(ele => {\r\n      const eleId = ele.dataset.effectId\r\n      if (drawnKeys[eleId]) {\r\n        drawnKeys[eleId].push(ele)\r\n      }\r\n      else {\r\n        drawnKeys[eleId] = [ele]\r\n      }\r\n      switch (ele.dataset.type) {\r\n        case 'dvd':\r\n          drawDvd(ele, dt)// / 1000)\r\n          break\r\n        case 'ad':\r\n          drawAd(ele, dt)// / 1000)\r\n          break\r\n      }\r\n    })\r\n\r\n    const callKeys = Object.keys(drawCalls)\r\n    callKeys.forEach(id => {\r\n      switch (drawCalls[id].type) {\r\n        case 'dvd':\r\n          if (!drawnKeys[id]) {\r\n            for (let i = 0; i < drawCalls[id].data.count; i++) {\r\n              addDvd(drawCalls[id].data)\r\n            }\r\n          }\r\n          else {\r\n            //drawnKeys[id].forEach(ele => drawDvd(ele, drawCalls[id].data, dt / 1000))\r\n          }\r\n          break;\r\n        case 'ad':\r\n          if (!drawnKeys[id]) {\r\n            for (let i = 0; i < drawCalls[id].data.count; i++) {\r\n              addAd(drawCalls[id].data)\r\n            }\r\n          }\r\n          else {\r\n            //drawnKeys[id].forEach(ele => drawAd(ele, drawCalls[id].data, dt))\r\n          }\r\n          break;\r\n        default:\r\n      }\r\n    })\r\n\r\n    drawnElements.forEach(ele => {\r\n      if (ele.dataset.lifeLeft <= -0.1) {\r\n        ele.remove()\r\n      }\r\n    })\r\n\r\n    drawCalls = {}\r\n    drawTime = 0\r\n  }\r\n\r\n  prevDrawTime = time\r\n  requestAnimationFrame(updateUI)\r\n}\r\n\r\nconst initialize = (scope) => {\r\n  alertContainer = scope.rootElement.querySelector('.btc-alert-container')\r\n  effectContainer = scope.rootElement.querySelector('.btc-effect-container')\r\n  copyContainer = scope.rootElement.querySelector('.btc-copy-container')\r\n  levelContainer = scope.rootElement.querySelector('.btc-combo-level-container')\r\n  comboCountContainer = scope.rootElement.querySelector('.btc-combo-info-container')\r\n  comboCount = scope.rootElement.querySelector('.btc-combo-count')\r\n  comboCountInner = scope.rootElement.querySelector('.btc-combo-count-inner')\r\n  canvasEle = scope.rootElement.querySelector('.fullscreen-canvas')\r\n  context = canvasEle.getContext('2d')\r\n  blackoutContainer = effectContainer.querySelector('.btc-effect-blackout-container')\r\n  buttonContainer = scope.rootElement.querySelector('#btc-button-container')\r\n\r\n  window.addEventListener('resize', () => {\r\n    windowSize.w = effectContainer.clientWidth\r\n    windowSize.h = effectContainer.clientHeight\r\n\r\n    visualBounds.xMin = blackoutContainer.offsetLeft + shakePos.x\r\n    visualBounds.xMax = blackoutContainer.offsetLeft + blackoutContainer.clientWidth + shakePos.x\r\n    visualBounds.yMin = blackoutContainer.offsetTop + shakePos.y\r\n    visualBounds.yMax = blackoutContainer.offsetTop + blackoutContainer.clientHeight + shakePos.y\r\n\r\n    canvasEle.style.width = `${windowSize.w}px`\r\n    canvasEle.style.height = `${windowSize.h}px`\r\n    canvasEle.width = windowSize.w\r\n    canvasEle.height = windowSize.h\r\n    drawCanvasEle.width = windowSize.w\r\n    drawCanvasEle.height = windowSize.h\r\n\r\n    clearCanvas()\r\n  })\r\n\r\n  setTimeout(() => {\r\n    windowSize.w = effectContainer.clientWidth\r\n    windowSize.h = effectContainer.clientHeight\r\n\r\n    visualBounds.xMin = blackoutContainer.offsetLeft + shakePos.x\r\n    visualBounds.xMax = blackoutContainer.offsetLeft + blackoutContainer.clientWidth + shakePos.x\r\n    visualBounds.yMin = blackoutContainer.offsetTop + shakePos.y\r\n    visualBounds.yMax = blackoutContainer.offsetTop + blackoutContainer.clientHeight + shakePos.y\r\n\r\n    canvasEle.style.width = `${windowSize.w}px`\r\n    canvasEle.style.height = `${windowSize.h}px`\r\n    canvasEle.width = windowSize.w\r\n    canvasEle.height = windowSize.h\r\n    drawCanvasEle.width = windowSize.w\r\n    drawCanvasEle.height = windowSize.h\r\n\r\n    initializeContextImages(scope)\r\n\r\n    clearCanvas()\r\n  }, 50)\r\n\r\n  scope.$on('BTCEffect-dvd', (e, data) => {\r\n    const keys = Object.keys(data).filter(c => c !== 'count')\r\n    keys.forEach(id => {\r\n      drawCalls[id] = {\r\n        type: 'dvd',\r\n        data: data[id],\r\n      }\r\n    });\r\n  })\r\n\r\n  scope.$on('BTCEffect-ad', (e, data) => {\r\n    const keys = Object.keys(data).filter(c => c !== 'count')\r\n    keys.forEach(id => {\r\n      drawCalls[id] = {\r\n        type: 'ad',\r\n        data: data[id],\r\n      }\r\n    });\r\n  })\r\n\r\n  scope.$on('BTCEffect-clear', () => {\r\n    const drawnElements = effectContainer.querySelectorAll('[data-effect-id]')\r\n\r\n    drawnElements.forEach(ele => {\r\n      ele.remove()\r\n    })\r\n    drawCalls = {}\r\n  })\r\n\r\n  scope.$on('BTCEffect-screen', (e, data) => {\r\n    if (data.shakeLife) {\r\n      shakePos.x = (shakePos.x / 1.02) + ((Math.random() - 0.5) * Math.min(Math.max(1, data.shakeLevel), 10) * 15)\r\n      shakePos.y = (shakePos.y / 1.02) + ((Math.random() - 0.5) * Math.min(Math.max(1, data.shakeLevel), 10) * 15)\r\n\r\n      blackoutContainer.style.transform = `translate(${shakePos.x}px, ${shakePos.y}px)`\r\n    }\r\n    else {\r\n      shakePos.x = 0\r\n      shakePos.y = 0\r\n\r\n      blackoutContainer.style.transform = `translate(${shakePos.x}px, ${shakePos.y}px)`\r\n    }\r\n    if (data.squishLife > 0) {\r\n      blackoutContainer.style.width = `calc(100vw - ${32 + (2 * data.squishLevel)}vw)`\r\n      blackoutContainer.style.left = `calc(${16 + data.squishLevel}vw)`\r\n    }\r\n    else {\r\n      blackoutContainer.style.width = `calc(100vw)`\r\n      blackoutContainer.style.left = `0px`\r\n    }\r\n    if (data.narrowLife > 0) {\r\n      blackoutContainer.style.height = `calc(100vh - ${32 + (2 * data.narrowLevel)}vh)`\r\n      blackoutContainer.style.top = `calc(${16 + data.narrowLevel}vh)`\r\n    }\r\n    else {\r\n      blackoutContainer.style.height = `calc(100vh)`\r\n      blackoutContainer.style.top = `0px`\r\n    }\r\n  })\r\n\r\n  scope.$on('BTCEffect-cc', (e, data) => {\r\n    ccData = data\r\n  })\r\n\r\n  scope.$on('BTCEffect-ccSwitch', (e, data) => {\r\n    if (data.oldState === 'transition_in' && data.newState === 'active') {\r\n      comboCountContainer.classList.add('btc-classic-mode')\r\n      alertContainer.classList.add('btc-classic-mode')\r\n    } else if (data.oldState === 'transition_out' && data.newState === 'off') {\r\n      comboCountContainer.classList.remove('btc-classic-mode')\r\n      alertContainer.classList.remove('btc-classic-mode')\r\n      clearCCEffectList()\r\n    }\r\n  })\r\n\r\n  scope.$on('BTCEffect-clippy', (e, data) => {\r\n    if (!data.isEmpty()) {\r\n      data.forEach((clippy) => {\r\n        for (let i = 0; i < clippy.count; i++) {\r\n          if (clippys[`${clippy.id}.${i}`] === undefined) {\r\n            // Create a new clippy\r\n            clippys[`${clippy.id}.${i}`] = {\r\n              position: {\r\n                x: Math.random() * (windowSize.w / 2 - 110) + windowSize.w / 4,\r\n                y: Math.random() * (windowSize.h / 2 - 125) + windowSize.h / 4,\r\n              },\r\n              lifeLeft: clippy.clips[i].lifeLeft || 10,\r\n              popInTime: 0.25 + Math.random() * 0.5,\r\n              level: clippy.clips[i].level,\r\n              id: clippy.id,\r\n              copyId: i,\r\n              lastCheckTime: -0.1, // Small buffer in case there's a delay\r\n              type: clippy.clips[i].type,\r\n            }\r\n          } else {\r\n            // When it gets ignored, the lifeLeft goes up so reset position\r\n            if (clippy.clips[i].lifeLeft > clippys[`${clippy.id}.${i}`].lifeLeft + 0.25) {\r\n              clippys[`${clippy.id}.${i}`].position = {\r\n                x: Math.random() * (windowSize.w / 2 - 110) + windowSize.w / 4,\r\n                y: Math.random() * (windowSize.h / 2 - 125) + windowSize.h / 4,\r\n              }\r\n              clippys[`${clippy.id}.${i}`].popInTime = 0.25 + Math.random() * 0.5\r\n              clippys[`${clippy.id}.${i}`].type = clippy.clips[i].type\r\n              removeClippyButtons(`${clippy.id}-${i}`)\r\n            }\r\n            clippys[`${clippy.id}.${i}`].lifeLeft = clippy.clips[i].lifeLeft\r\n            clippys[`${clippy.id}.${i}`].lastCheckTime = -0.1 // Small buffer in case there's a delay\r\n          }\r\n        }\r\n      })\r\n    }\r\n  })\r\n\r\n  scope.$on('BTCEffect-winError', (e, data) => {if (!data.isEmpty()) {\r\n    data.forEach((err) => {\r\n      if (winErrors[`${err.id}`] === undefined) {\r\n        // Create a new clippy\r\n        const position = {\r\n          x: Math.random() * (windowSize.w / 2 - 110) + windowSize.w / 4,\r\n          y: Math.random() * (windowSize.h / 2 - 125) + windowSize.h / 4,\r\n        }\r\n        winErrors[`${err.id}`] = {\r\n          lifeLeft: err.lifeLeft || 10,\r\n          isCrashing: err.isCrashing || false,\r\n          level: err.level,\r\n          id: err.id,\r\n          lastCheckTime: -0.1, // Small buffer in case there's a delay\r\n          velocity: {\r\n            x: (Math.random() * 2 - 1) * 50,\r\n            y: 0,\r\n          },\r\n          boxes: [{\r\n            crashTime: 0,\r\n            position,\r\n          }]\r\n        }\r\n      } else {\r\n        winErrors[`${err.id}`].lifeLeft = err.lifeLeft\r\n        winErrors[`${err.id}`].isCrashing = err.isCrashing\r\n        winErrors[`${err.id}`].lastCheckTime = -0.1 // Small buffer in case there's a delay\r\n      }\r\n    })\r\n  }\r\n  })\r\n\r\n  scope.$on('BTCFrameUpdate', (e, data) => {\r\n    frameTime = data\r\n  })\r\n\r\n  comboCountInner.addEventListener('click', (e) => {\r\n    let count = 5\r\n    if (e.shiftKey) {\r\n      count *= 5\r\n    }\r\n    if (e.ctrlKey) {\r\n      count *= 2\r\n    }\r\n    console.log(count)\r\n    bngApi.engineLua(`freeroam_beamTwitchChaos.addRandomCommand(${count})`)\r\n  })\r\n\r\n  requestAnimationFrame(updateUI)\r\n}\r\n\r\nconst initializeContextImages = (scope) => {\r\n  const imageLoader = scope.rootElement.querySelector('#image-loader')\r\n  const clippyImage = imageLoader.querySelector('#clippy')\r\n  const clippyImageBlank = imageLoader.querySelector('#clippy_empty')\r\n\r\n  imagePatterns.clippy = drawContext.createPattern(clippyImage, 'repeat')\r\n  imagePatterns.clippyBlank = drawContext.createPattern(clippyImageBlank, 'repeat')\r\n\r\n  imageLoader.classList.add('btc-hidden')\r\n}\r\n\r\n\n\n//# sourceURL=webpack://beamtwitchchaos/./src/js/ui-effects.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/index.js");
/******/ 	
/******/ })()
;