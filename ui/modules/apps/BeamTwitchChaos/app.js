/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/styles/index.less":
/*!*******************************!*\
  !*** ./src/styles/index.less ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://beamtwitchchaos/./src/styles/index.less?");

/***/ }),

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   app: () => (/* binding */ app),\n/* harmony export */   settings: () => (/* binding */ settings)\n/* harmony export */ });\n/* harmony import */ var _connection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./connection */ \"./src/js/connection.js\");\n/* harmony import */ var _ui_effects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ui-effects */ \"./src/js/ui-effects.js\");\n\r\n\r\n\r\nconst settings = {\r\n  autoConnect: false,\r\n}\r\n\r\nconst loadSettings = (loaded) => {\r\n  const settingsKeys = Object.keys(loaded)\r\n  settingsKeys.forEach(setKey => {\r\n    settings[setKey] = loaded[setKey]\r\n  })\r\n}\r\n\r\nconst app = (scope, element) => {\r\n  scope.rootElement = element[0]\r\n  ;(0,_connection__WEBPACK_IMPORTED_MODULE_0__.initialize)(scope)\r\n  ;(0,_ui_effects__WEBPACK_IMPORTED_MODULE_1__.initialize)(scope)\r\n\r\n  scope.$on('BTCApplySettings', (e, data) => {\r\n    //console.dir(e)\r\n    loadSettings(data)\r\n  })\r\n  scope.$on('BTCSettingsSaved', (e) => {\r\n    //console.dir(e)\r\n  })\r\n\r\n  bngApi.engineLua(`freeroam_beamTwitchChaos.loadSettingsFile()`)\r\n  bngApi.engineLua(`freeroam_beamTwitchChaos.checkServerStatus()`)\r\n}\r\n\n\n//# sourceURL=webpack://beamtwitchchaos/./src/js/app.js?");

/***/ }),

/***/ "./src/js/connection.js":
/*!******************************!*\
  !*** ./src/js/connection.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONNECTION_STATUS: () => (/* binding */ CONNECTION_STATUS),\n/* harmony export */   CONNECTION_STATUS_LABELS: () => (/* binding */ CONNECTION_STATUS_LABELS),\n/* harmony export */   initialize: () => (/* binding */ initialize)\n/* harmony export */ });\n/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./app */ \"./src/js/app.js\");\n\r\n\r\nconst CONNECTION_STATUS = {\r\n  CONNECTED: 'connected',\r\n  DISCONNECTED: 'disconnected',\r\n  LOST_CONNECTION: 'lost_connection',\r\n  RECONNECT: 'reconnecting',\r\n}\r\n\r\nconst CONNECTION_STATUS_LABELS = {\r\n  [CONNECTION_STATUS.CONNECTED]: 'Connected',\r\n  [CONNECTION_STATUS.DISCONNECTED]: 'Disconnected',\r\n  [CONNECTION_STATUS.LOST_CONNECTION]: 'Lost Connection',\r\n  [CONNECTION_STATUS.RECONNECT]: 'Reconnecting...',\r\n}\r\n\r\nconst state = {\r\n  status: CONNECTION_STATUS.DISCONNECTED,\r\n  statusEle: null,\r\n  lastConnectionAttemptTime: null,\r\n  lastConnectionAttemptCount: 0,\r\n  lastConnectionAttemptInterval: null,\r\n  currentCombo: 0,\r\n}\r\nconst elements = {\r\n  status: null,\r\n  statusText: null,\r\n  connect: null,\r\n  reconnect: null,\r\n  disconnect: null,\r\n  boardEle: null,\r\n  comboLevel: null,\r\n  comboInner: null,\r\n  comboHighest: null,\r\n  comboOnes: null,\r\n  comboTens: null,\r\n  comboHund: null,\r\n  vehicleLoadText: null,\r\n}\r\nlet debugEl = null\r\n\r\nconst tryServerConnect = (connectionAttempts = 0) => {\r\n  if (connectionAttempts === 0 && state.lastConnectionAttemptInterval) {\r\n    clearTimeout(state.lastConnectionAttemptInterval)\r\n  }\r\n\r\n  state.status = CONNECTION_STATUS.RECONNECT\r\n  elements.statusText.textContent = CONNECTION_STATUS_LABELS[state.status]\r\n  elements.status.dataset.status = state.status\r\n\r\n  if (connectionAttempts < 5) {\r\n    console.log(\"reconnection attempt: %d\", connectionAttempts + 1)\r\n    bngApi.engineLua(`freeroam_beamTwitchChaos.connectToServer()`)\r\n    state.lastConnectionAttemptTime = new Date().getUTCMilliseconds()\r\n    state.lastConnectionAttemptCount += 1\r\n    state.lastConnectionAttemptInterval =\r\n      setTimeout(\r\n        () => tryServerConnect(state.lastConnectionAttemptCount),\r\n        state.lastConnectionAttemptCount * 1000)\r\n  } else {\r\n    state.lastConnectionAttemptTime = null\r\n    state.lastConnectionAttemptInterval = null\r\n    state.lastConnectionAttemptCount = 0\r\n    state.status = CONNECTION_STATUS.DISCONNECTED\r\n    elements.statusText.textContent = CONNECTION_STATUS_LABELS[state.status]\r\n    elements.status.dataset.status = state.status\r\n    elements.disconnect.classList.add('btc-hidden')\r\n    elements.reconnect.classList.add('btc-hidden')\r\n    elements.connect.classList.remove('btc-hidden')\r\n  }\r\n}\r\n\r\nconst triggerCommandAlert = (commandData) => {\r\n  const alertMidTime = 2350\r\n  const alertEndTime = 150\r\n  const alert = document.createElement('div')\r\n  alert.classList.add('btc-effect-alert', 'btc-effect-alert-start')\r\n  alert.dataset.alertId = commandData.id\r\n\r\n  let message = 'triggered a random command'\r\n  switch (commandData.code) {\r\n    case 'dvd_1':\r\n    case 'dvd_5':\r\n    case 'dvd_10':\r\n    case 'dvd':\r\n      message = 'added DVD logos'\r\n      break;\r\n    case 'ad_1':\r\n    case 'ad_5':\r\n    case 'ad_10':\r\n    case 'ad':\r\n      message = 'added ads'\r\n      break;\r\n    case 'view_narrow':\r\n    case 'view_squish':\r\n    case 'view_shake':\r\n      message = 'wants to see less'\r\n      break;\r\n    case 'pop':\r\n      message = 'triggered a tire to pop'\r\n      break;\r\n    case 'alarm':\r\n      message = 'thinks this car is stolen'\r\n      break;\r\n    case 'ignition':\r\n      message = 'doesn\\'t want to keep moving'\r\n      break;\r\n    case 'fire':\r\n      message = 'triggered the car to catch fire'\r\n      break;\r\n    case 'explode':\r\n      message = 'triggered the car to explode'\r\n      break;\r\n    case 'nudge_l':\r\n    case 'nudge_r':\r\n    case 'kick_l':\r\n    case 'kick_r':\r\n      message = 'gave a bit of a nudge'\r\n      break;\r\n    case 'tilt_l':\r\n    case 'tilt_r':\r\n    case 'roll_l':\r\n    case 'roll_r':\r\n      message = 'went car tipping'\r\n      break;\r\n    case 'boost_l':\r\n    case 'boost_h':\r\n      message = 'engaged boost'\r\n      break;\r\n    case 'jump_l':\r\n    case 'jump_h':\r\n      message = 'wants to jump this car'\r\n      break;\r\n    case 'sticky_throttle':\r\n      message = 'wants to go faster'\r\n      break;\r\n    case 'sticky_brake':\r\n      message = 'wants to go slower'\r\n      break;\r\n    case 'sticky_parkingbrake':\r\n      message = 'wants to drift'\r\n      break;\r\n    case 'sticky_turn_l':\r\n    case 'sticky_turn_r':\r\n      message = 'wants to go that way'\r\n      break;\r\n    case 'extinguish':\r\n      message = 'extinguished the car'\r\n      break;\r\n    case 'ghost':\r\n      message = 'invited a ghost'\r\n      break;\r\n    case 'daytime':\r\n      message = 'turned the lights on'\r\n      break;\r\n    case 'nighttime':\r\n      message = 'turned the lights off'\r\n      break;\r\n    case 'randomtime':\r\n      message = 'turned the lights somewhere'\r\n      break;\r\n    case 'timescale':\r\n      message = 'spun the world really fast'\r\n      break;\r\n    case 'gravity_grav_pluto':\r\n    case 'gravity_grav_moon':\r\n    case 'gravity_grav_mars':\r\n    case 'gravity_grav_venus':\r\n    case 'gravity_grav_saturn':\r\n    case 'gravity_grav_jupiter':\r\n    case 'gravity_grav_double_earth':\r\n    case 'gravity':\r\n      message = 'wants to feel like they\\'re on another planet'\r\n      break;\r\n    case 'simscale':\r\n      message = 'wants to see that in slow-motion'\r\n      break;\r\n    case 'camera_change':\r\n      message = 'wants a better view'\r\n      break;\r\n    case 'camera_up':\r\n    case 'camera_down':\r\n    case 'camera_right':\r\n    case 'camera_left':\r\n    case 'camera_in':\r\n    case 'camera_out':\r\n      message = 'wants to look that way'\r\n      break;\r\n    case 'drop_cone':\r\n      message = 'tossed a cone your way'\r\n      break;\r\n    case 'drop_piano':\r\n      message = 'wants to hear some music'\r\n      break;\r\n    case 'drop_taxi':\r\n      message = 'hailed a cab'\r\n      break;\r\n    case 'drop_bus':\r\n      message = 'wants to get off at the next bus stop'\r\n      break;\r\n    case 'drop_traffic':\r\n      message = 'spotted some traffic up ahead'\r\n      break;\r\n    case 'kickflip':\r\n      message = 'wants to see some sick tricks'\r\n      break;\r\n    case 'spin':\r\n      message = 'forgot something at our last stop'\r\n      break;\r\n    case 'slam':\r\n      message = 'thinks this is a lowrider'\r\n      break;\r\n    case 'random_paint':\r\n      message = 'thought up a nice paint scheme'\r\n      break;\r\n    case 'random_tune':\r\n      message = 'messed with the tuning sliders'\r\n      break;\r\n    case 'random_part':\r\n      message = 'rummaged through a spare parts bin'\r\n      break;\r\n    case 'meteors':\r\n      message = 'spotted something in the sky'\r\n      break;\r\n    case 'fireworks':\r\n      message = 'wants to see some fireworks'\r\n      break;\r\n    case 'uireset':\r\n      message = 'cleaned up the view'\r\n      break;\r\n    case 'test':\r\n      message = 'triggered the test command somehow'\r\n      break;\r\n    default:\r\n      message = 'triggered a mystery command'\r\n  }\r\n  alert.innerText = `${commandData.viewer} ${message}`\r\n  setTimeout(() => {\r\n    alert.classList.remove('btc-effect-alert-start')\r\n    setTimeout(() => {\r\n      alert.classList.add('btc-effect-alert-end')\r\n      setTimeout(() => {\r\n        alert.remove()\r\n      }, alertEndTime)\r\n    }, alertMidTime)\r\n  }, 1)\r\n  elements.boardEle.append(alert)\r\n}\r\n\r\nconst initialize = (scope) => {\r\n  elements.boardEle = scope.rootElement.querySelector('.btc-alert-container')\r\n  elements.comboLevel = scope.rootElement.querySelector('.btc-combo-level')\r\n  elements.comboHighest = scope.rootElement.querySelector('.btc-combo-highest')\r\n  elements.comboInner = scope.rootElement.querySelector('.btc-combo-count-inner')\r\n  elements.comboOnes = scope.rootElement.querySelector('#btc-ones')\r\n  elements.comboTens = scope.rootElement.querySelector('#btc-tens')\r\n  elements.comboHund = scope.rootElement.querySelector('#btc-hund')\r\n  elements.vehicleLoadText = elements.boardEle.querySelector('#btc-vehicle-countdown')\r\n\r\n  elements.status = scope.rootElement.querySelector('#btc-server-status-container')\r\n  elements.statusText = scope.rootElement.querySelector('#btc-server-status-text')\r\n  elements.statusText.textContent = CONNECTION_STATUS_LABELS[state.status]\r\n  elements.status.dataset.status = state.status\r\n\r\n  elements.disconnect = scope.rootElement.querySelector('#btc-disconnect-server')\r\n  elements.connect = scope.rootElement.querySelector('#btc-connect-server')\r\n  elements.reconnect = scope.rootElement.querySelector('#btc-reconnect-server')\r\n\r\n  debugEl = scope.rootElement.querySelector('#debug-text')\r\n\r\n  scope.$on('BTCServerConnected', () => {\r\n    if (state.status === CONNECTION_STATUS.LOST_CONNECTION\r\n      || state.lastConnectionAttemptInterval) {\r\n      console.log('connected')\r\n      state.status = CONNECTION_STATUS.CONNECTED\r\n      elements.statusText.textContent = CONNECTION_STATUS_LABELS[state.status]\r\n      elements.status.dataset.status = state.status\r\n\r\n      clearTimeout(state.lastConnectionAttemptInterval)\r\n      state.lastConnectionAttemptTime = null\r\n      state.lastConnectionAttemptInterval = null\r\n      state.lastConnectionAttemptCount = 0\r\n    }\r\n\r\n    elements.disconnect.classList.remove('btc-hidden')\r\n    elements.reconnect.classList.remove('btc-hidden')\r\n    elements.connect.classList.add('btc-hidden')\r\n  })\r\n  scope.$on('BTCServerDisconnected', () => {\r\n    console.log('disconnected')\r\n    state.status = CONNECTION_STATUS.DISCONNECTED\r\n    elements.statusText.textContent = CONNECTION_STATUS_LABELS[state.status]\r\n    elements.status.dataset.status = state.status\r\n\r\n    elements.disconnect.classList.add('btc-hidden')\r\n    elements.reconnect.classList.add('btc-hidden')\r\n    elements.connect.classList.remove('btc-hidden')\r\n  })\r\n  scope.$on('BTCServerLostConnection', () => {\r\n    console.log('lost connection')\r\n    state.status = CONNECTION_STATUS.LOST_CONNECTION\r\n    elements.status.dataset.status = state.status\r\n    elements.statusText.textContent = CONNECTION_STATUS_LABELS[state.status]\r\n    setTimeout(() => {\r\n      if (state.status === CONNECTION_STATUS.LOST_CONNECTION) {\r\n        state.status = CONNECTION_STATUS.DISCONNECTED\r\n        elements.statusText.textContent = CONNECTION_STATUS_LABELS[state.status]\r\n        elements.status.dataset.status = state.status\r\n\r\n        elements.disconnect.classList.add('btc-hidden')\r\n        elements.reconnect.classList.add('btc-hidden')\r\n        elements.connect.classList.remove('btc-hidden')\r\n      }\r\n    }, 2000)\r\n\r\n    if (_app__WEBPACK_IMPORTED_MODULE_0__.settings.autoConnect\r\n      && !state.lastConnectionAttemptInterval) {\r\n      tryServerConnect(state.lastConnectionAttemptCount)\r\n      elements.disconnect.classList.remove('btc-hidden')\r\n      elements.reconnect.classList.add('btc-hidden')\r\n      elements.connect.classList.add('btc-hidden')\r\n    }\r\n  })\r\n  scope.$on('BTCServerStatus', (e, data) => {\r\n    if (data === 'connected') {\r\n      console.log('connected')\r\n      state.status = CONNECTION_STATUS.CONNECTED\r\n      elements.statusText.textContent = CONNECTION_STATUS_LABELS[state.status]\r\n      elements.status.dataset.status = state.status\r\n\r\n      clearTimeout(state.lastConnectionAttemptInterval)\r\n      state.lastConnectionAttemptTime = null\r\n      state.lastConnectionAttemptInterval = null\r\n      state.lastConnectionAttemptCount = 0\r\n\r\n      elements.disconnect.classList.remove('btc-hidden')\r\n      elements.reconnect.classList.remove('btc-hidden')\r\n      elements.connect.classList.add('btc-hidden')\r\n    }\r\n    else if (data === 'disconnected') {\r\n      console.log('disconnected')\r\n      state.status = CONNECTION_STATUS.DISCONNECTED\r\n      elements.statusText.textContent = CONNECTION_STATUS_LABELS[state.status]\r\n      elements.status.dataset.status = state.status\r\n\r\n      clearTimeout(state.lastConnectionAttemptInterval)\r\n      state.lastConnectionAttemptTime = null\r\n      state.lastConnectionAttemptInterval = null\r\n      state.lastConnectionAttemptCount = 0\r\n\r\n      elements.disconnect.classList.add('btc-hidden')\r\n      elements.reconnect.classList.add('btc-hidden')\r\n      elements.connect.classList.remove('btc-hidden')\r\n    }\r\n  })\r\n  scope.$on('BTCServerResponse', (e, data) => {\r\n    let dataString = data\r\n    dataString = dataString.substring(1, dataString.lastIndexOf('}') + 1).replace(/\\\\\"/g, '\"')\r\n    //console.dir(JSON.parse(dataString))\r\n    debugEl.textContent = dataString\r\n  })\r\n  scope.$on('BTCUpdateCombo', (e, data) => {\r\n    if (data.combo.current > state.currentCombo) {\r\n      elements.comboInner.classList.remove('btc-combo-add')\r\n      void elements.comboInner.offsetWidth\r\n      elements.comboInner.classList.add('btc-combo-add')\r\n    }\r\n    state.currentCombo = data.combo.current\r\n    elements.comboLevel.innerText = data.combo.level\r\n    elements.comboHighest.innerText = data.combo.highest\r\n    elements.comboInner.dataset.effectCount = data.combo.current\r\n    if (data.combo.current < 10) {\r\n      elements.comboOnes.classList.add('btc-combo-hidden')\r\n      elements.comboTens.classList.add('btc-combo-hidden')\r\n      elements.comboHund.innerText = data.combo.current\r\n    }\r\n    else if (data.combo.current < 100) {\r\n      elements.comboOnes.classList.add('btc-combo-hidden')\r\n      elements.comboTens.classList.remove('btc-combo-hidden')\r\n      elements.comboHund.innerText = Math.floor(data.combo.current / 10)\r\n      elements.comboTens.innerText = data.combo.current % 10\r\n    }\r\n    else if (data.combo.current < 1000) {\r\n      elements.comboOnes.classList.remove('btc-combo-hidden')\r\n      elements.comboTens.classList.remove('btc-combo-hidden')\r\n      elements.comboHund.innerText = Math.floor(data.combo.current / 100)\r\n      elements.comboTens.innerText = Math.floor((data.combo.current % 100) / 10)\r\n      elements.comboOnes.innerText = data.combo.current % 10\r\n    }\r\n    else {\r\n      elements.comboOnes.classList.remove('btc-combo-hidden')\r\n      elements.comboTens.classList.remove('btc-combo-hidden')\r\n      elements.comboHund.innerText = 9\r\n      elements.comboTens.innerText = 9\r\n      elements.comboOnes.innerText = 9\r\n    }\r\n  })\r\n  scope.$on('BTCPrepCommand', (e, data) => {\r\n    //console.debug(data)\r\n    triggerCommandAlert(data)\r\n  })\r\n  scope.$on('BTCTriggerCommand', (e, data) => {\r\n    //console.debug(data)\r\n  })\r\n  scope.$on('BTCDebug-DATA', (e, data) => {\r\n    console.debug(data)\r\n  })\r\n  scope.$on('BTCPingUI', () => {\r\n    bngApi.engineLua(`freeroam_beamTwitchChaos.pongUI()`)\r\n  })\r\n\r\n  scope.$on('BTCVehicleCountdown', (e, data) => {\r\n    if (data <= 0) {\r\n      elements.vehicleLoadText.classList.add('btc-hidden')\r\n    }\r\n    else {\r\n      elements.vehicleLoadText.classList.remove('btc-hidden')\r\n      const countdownTime = Math.floor(data)\r\n\r\n      if (countdownTime === 0) {\r\n        elements.vehicleLoadText.innerText = 'Vehicle load checking now (may cause lag)'\r\n      }\r\n      else {\r\n        elements.vehicleLoadText.innerText = `Vehicle load check in: ${countdownTime} (may cause lag)`\r\n      }\r\n    }\r\n  })\r\n\r\n  elements.disconnect.addEventListener('click', () => {\r\n    elements.disconnect.classList.add('btc-hidden')\r\n    elements.reconnect.classList.remove('btc-hidden')\r\n    elements.connect.classList.remove('btc-hidden')\r\n\r\n    bngApi.engineLua(`freeroam_beamTwitchChaos.disconnectToServer()`)\r\n\r\n    if (state.lastConnectionAttemptInterval) {\r\n      clearTimeout(state.lastConnectionAttemptInterval)\r\n      state.lastConnectionAttemptTime = null\r\n      state.lastConnectionAttemptInterval = null\r\n      state.lastConnectionAttemptCount = 0\r\n    }\r\n  })\r\n  elements.reconnect.addEventListener('click', () => {\r\n    elements.disconnect.classList.remove('btc-hidden')\r\n    elements.reconnect.classList.remove('btc-hidden')\r\n    elements.connect.classList.add('btc-hidden')\r\n\r\n    bngApi.engineLua(`freeroam_beamTwitchChaos.disconnectToServer()`)\r\n    tryServerConnect(state.lastConnectionAttemptCount, true)\r\n  })\r\n  elements.connect.addEventListener('click', () => {\r\n    elements.disconnect.classList.remove('btc-hidden')\r\n    elements.reconnect.classList.remove('btc-hidden')\r\n    elements.connect.classList.add('btc-hidden')\r\n\r\n    tryServerConnect(state.lastConnectionAttemptCount)\r\n  })\r\n}\n\n//# sourceURL=webpack://beamtwitchchaos/./src/js/connection.js?");

/***/ }),

/***/ "./src/js/index.js":
/*!*************************!*\
  !*** ./src/js/index.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _styles_index_less__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../styles/index.less */ \"./src/styles/index.less\");\n/* harmony import */ var _test__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./test */ \"./src/js/test.js\");\n/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./app */ \"./src/js/app.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nangular.module('beamng.apps')\r\n  .directive('beamTwitchChaos', [() => {\r\n    return {\r\n      templateUrl: '/ui/modules/apps/BeamTwitchChaos/app.html',\r\n      replace: true,\r\n      restrict: 'EA',\r\n      link: (scope, element,) => {\r\n        scope.app = (0,_app__WEBPACK_IMPORTED_MODULE_2__.app)(scope, element)\r\n\r\n        scope.settings = {\r\n          autoConnect: true,\r\n        }\r\n\r\n        scope.buttons = []\r\n        scope.menus = {}\r\n        scope.currentMenu = null\r\n        scope.commandList = {}\r\n\r\n        scope.initialize = () => {\r\n          const menuButtons = scope.rootElement.querySelectorAll('.btc-menu-button')\r\n          const menus = scope.rootElement.querySelectorAll('.btc-menu')\r\n          menus.forEach(menu => {\r\n            scope.menus[menu.dataset.loc] = {\r\n              ele: menu,\r\n              loc: menu.dataset.loc,\r\n              state: menu.classList.contains('btc-open') ? 'open' : 'closed',\r\n            }\r\n\r\n            if (menu.classList.contains('btc-open') && !scope.currentMenu) {\r\n              scope.currentMenu = menu.dataset.loc\r\n            }\r\n            else {\r\n              (0,_test__WEBPACK_IMPORTED_MODULE_1__.toggleMenu)(scope.menus[menu.dataset.loc])\r\n            }\r\n          })\r\n          menuButtons.forEach(button => {\r\n            scope.buttons.push({\r\n              ele: button,\r\n              loc: button.dataset.loc,\r\n            })\r\n\r\n            button.addEventListener('click', () => {\r\n              ;(0,_test__WEBPACK_IMPORTED_MODULE_1__.toggleMenu)(scope.menus[scope.currentMenu])\r\n              ;(0,_test__WEBPACK_IMPORTED_MODULE_1__.toggleMenu)(scope.menus[button.dataset.loc], 'open')\r\n              scope.currentMenu = button.dataset.loc\r\n            })\r\n          })\r\n        }\r\n        scope.initialize()\r\n      }\r\n    };\r\n  }]);\r\n\r\nconst commands = {\r\n  pop: {\r\n    name: 'Pop',\r\n    desc: 'Pops tires and breaks wheels',\r\n    bitsDefault: 20,\r\n    funcCall: 'pop',\r\n  },\r\n  color: {\r\n    name: 'Color',\r\n    desc: 'Changes a part, or a random part, to a color, or a random color, or the entire car',\r\n    bitsDefault: 50,\r\n    funcCall: 'color',\r\n    settings: [\r\n      {\r\n        name: 'Part Control',\r\n        desc: 'If chat can specify a part or not',\r\n        type: Boolean,\r\n        default: true,\r\n      }\r\n    ],\r\n    options: [\r\n      {\r\n        name: 'Color',\r\n        desc: 'The color to change to. If not included, uses a random color',\r\n        type: String,\r\n        validation: 'pattern',\r\n        pattern: /#[0-9a-f]{1,6}/g,\r\n        missing: () => {\r\n          const r = Math.floor(Math.random() * 255).toString(16)\r\n          const g = Math.floor(Math.random() * 255).toString(16)\r\n          const b = Math.floor(Math.random() * 255).toString(16)\r\n\r\n          return `#${r}${g}${b}`\r\n        }\r\n      },\r\n      {\r\n        name: 'Part',\r\n        desc: 'The part to apply the color to, if enabled',\r\n        type: String,\r\n        validation: 'match',\r\n        match: ['hood', 'door', 'trunk'],\r\n        missing: () => {\r\n          return commands.color.options[2].match[Math.floor(Math.random() * commands.color.options[2].match.length)]\r\n        }\r\n      }\r\n    ]\r\n  }\r\n}\n\n//# sourceURL=webpack://beamtwitchchaos/./src/js/index.js?");

/***/ }),

/***/ "./src/js/test.js":
/*!************************!*\
  !*** ./src/js/test.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toggleMenu: () => (/* binding */ toggleMenu)\n/* harmony export */ });\n\r\nconst toggleMenu = (menu, state = 'closed') => {\r\n  if (state === 'closed') {\r\n    menu.ele.classList.add('btc-closed')\r\n    menu.ele.classList.remove('btc-open')\r\n  }\r\n  else if (state === 'open') {\r\n    menu.ele.classList.remove('btc-closed')\r\n    menu.ele.classList.add('btc-open')\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://beamtwitchchaos/./src/js/test.js?");

/***/ }),

/***/ "./src/js/ui-effects.js":
/*!******************************!*\
  !*** ./src/js/ui-effects.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initialize: () => (/* binding */ initialize)\n/* harmony export */ });\n\r\nlet effectContainer;\r\nlet copyContainer;\r\nlet canvasEle;\r\nlet context;\r\nconst windowSize = {\r\n  w: 0,\r\n  h: 0,\r\n}\r\nconst visualBounds = {\r\n  xMin: 0,\r\n  xMax: 0,\r\n  yMin: 0,\r\n  yMax: 0,\r\n}\r\nlet comboCount\r\nlet comboCountInner\r\nlet levelContainer\r\nlet blackoutContainer\r\n\r\nconst dvdSize = {\r\n  w: 210,\r\n  h: 107,\r\n}\r\nconst rainbow = [\r\n  'rgb(255, 51,  51)',\r\n  'rgb(255, 102,  51)',\r\n  'rgb(255, 204, 51)',\r\n  'rgb(51,  255, 51)',\r\n  'rgb(51,  51,  255)',\r\n  'rgb(102, 51,  255)',\r\n  'rgb(204, 51,  255)',\r\n]\r\nconst enterTypes = [\r\n  'ad-in-slide',\r\n  'ad-in-fade',\r\n]\r\nconst exitTypes = [\r\n  'ad-out-slide',\r\n  'ad-out-fade',\r\n]\r\nconst directions = [\r\n  'ad-left',\r\n  'ad-right',\r\n  'ad-top',\r\n  'ad-bottom',\r\n]\r\n\r\nlet shakePos = {\r\n  x: 0,\r\n  y: 0,\r\n}\r\n\r\nlet frameTime = 0.016\r\nlet drawTime = 0\r\nlet prevDrawTime = 0\r\nlet drawCalls = {}\r\n\r\nconst clearCanvas = () => {\r\n  context.clearRect(0, 0, windowSize.w, windowSize.h)\r\n}\r\n\r\nconst getScaledPosition = (gridPos, objSize) => {\r\n  return {\r\n    x: (gridPos.x / 100) * (windowSize.w - objSize.w),\r\n    y: (gridPos.y / 100) * (windowSize.h - objSize.h),\r\n  }\r\n}\r\n\r\nconst addDvd = (dvdData) => {\r\n  const drawSize = {\r\n    w: (windowSize.w / 1920) * dvdSize.w,\r\n    h: (windowSize.w / 1920) * dvdSize.h,\r\n  }\r\n  const drawPos = {\r\n    x: (Math.random() * (visualBounds.xMax - visualBounds.xMin - drawSize.w) + visualBounds.xMin),\r\n    y: (Math.random() * (visualBounds.yMax - visualBounds.yMin - drawSize.h) + visualBounds.yMin),\r\n  }\r\n\r\n  const newDvdImage = copyContainer.querySelector(\".btc-dvd-logo\").cloneNode(true)\r\n  newDvdImage.classList.add('btc-image-effect')\r\n  newDvdImage.dataset.effectId = dvdData.id\r\n  newDvdImage.dataset.level = dvdData.level || 0\r\n  newDvdImage.dataset.lifeLeft = dvdData.lifeLeft\r\n  const dir = Math.random() * Math.PI * 2\r\n  newDvdImage.dataset.xDir = dvdData.xDir || Math.sin(dir)\r\n  newDvdImage.dataset.yDir = dvdData.yDir || Math.cos(dir)\r\n  newDvdImage.dataset.xPos = drawPos.x\r\n  newDvdImage.dataset.yPos = drawPos.y\r\n  newDvdImage.dataset.cloned = dvdData.cloned || 'false'\r\n  newDvdImage.dataset.type = 'dvd'\r\n  newDvdImage.style.left = `${drawPos.x}px`\r\n  newDvdImage.style.top = `${drawPos.y}px`\r\n  newDvdImage.style.width = `${drawSize.w}px`\r\n  newDvdImage.style.height = `${drawSize.h}px`\r\n  newDvdImage.style.fill = rainbow[Math.floor(Math.random() * rainbow.length)]\r\n  effectContainer.append(newDvdImage)\r\n}\r\n\r\nconst addAd = (adData) => {\r\n  const newAdNum = Math.ceil(Math.random() * 14)\r\n  const newAd = copyContainer.querySelector(`.btc-ad-${newAdNum}`).cloneNode(true)\r\n  const drawSize = {\r\n    w: Number.parseInt(newAd.dataset.setWidth) || ((Number.parseInt(newAd.dataset.minWidth) || 200) + Math.random() * ((Number.parseInt(newAd.dataset.maxWidth) || 600) - (Number.parseInt(newAd.dataset.minWidth) || 200))),\r\n    h: Number.parseInt(newAd.dataset.setHeight) || ((Number.parseInt(newAd.dataset.minHeight) || 200) + Math.random() * ((Number.parseInt(newAd.dataset.maxHeight) || 600) - (Number.parseInt(newAd.dataset.minHeight) || 200))),\r\n  }\r\n\r\n  const inOutTime = Math.floor(250 + (Math.random() * 750))\r\n  const inDelay = Math.floor(Math.random() * 2000)\r\n  newAd.dataset.effectId = adData.id\r\n  newAd.dataset.inOutTime = inOutTime\r\n  newAd.dataset.inDelay = inDelay\r\n  newAd.dataset.lifeLeft = adData.lifeLeft + (inOutTime / 1000) + (inDelay / 1000)\r\n  newAd.dataset.maxLife = adData.lifeLeft + (inOutTime / 1000)\r\n  newAd.dataset.type = 'ad'\r\n  newAd.style.width = `${drawSize.w}px`\r\n  newAd.style.height = `${drawSize.h}px`\r\n  newAd.style.transition = `all ${inOutTime}ms`\r\n  effectContainer.append(newAd)\r\n\r\n  switch (newAd.dataset.adType) {\r\n    default:\r\n    case 'standard':\r\n      const drawPos = {\r\n        x: (Math.random() * (visualBounds.xMax - visualBounds.xMin - newAd.clientHeight) + visualBounds.xMin),\r\n        y: (Math.random() * (visualBounds.yMax - visualBounds.yMin - newAd.clientWidth) + visualBounds.yMin),\r\n      }\r\n      const enterType = enterTypes[Math.floor(Math.random() * enterTypes.length)]\r\n      const exitType = exitTypes[Math.floor(Math.random() * exitTypes.length)]\r\n      const direction = directions[Math.floor(Math.random() * directions.length)]\r\n\r\n      newAd.classList.add('btc-hidden', 'ad-in-out', enterType, exitType, direction)\r\n      newAd.dataset.xPos = drawPos.x\r\n      newAd.dataset.yPos = drawPos.y\r\n      newAd.style.left = `${drawPos.x}px`\r\n      newAd.style.top = `${drawPos.y}px`\r\n      newAd.querySelectorAll('button').forEach((button) => {\r\n        button.addEventListener('click', () => {\r\n          const drawSize = {\r\n            w: (Number.parseInt(newAd.dataset.extrawidth) || 0) + 100 + Math.random() * 350,\r\n            h: 200,\r\n          }\r\n          newAd.style.width = `${drawSize.w}px`\r\n          const drawPos = {\r\n            x: (Math.random() * (visualBounds.xMax - visualBounds.xMin - newAd.clientHeight) + visualBounds.xMin),\r\n            y: (Math.random() * (visualBounds.yMax - visualBounds.yMin - newAd.clientWidth) + visualBounds.yMin),\r\n          }\r\n          newAd.dataset.xPos = drawPos.x\r\n          newAd.dataset.yPos = drawPos.y\r\n          newAd.style.left = `${drawPos.x}px`\r\n          newAd.style.top = `${drawPos.y}px`\r\n        })\r\n      })\r\n      break\r\n    case 'banner':\r\n  }\r\n}\r\n\r\nconst drawDvd = (ele, dt) => {\r\n  const drawSize = {\r\n    w: (windowSize.w / 1920) * dvdSize.w,\r\n    h: (windowSize.w / 1920) * dvdSize.h,\r\n  }\r\n  const drawPos = {\r\n    x: Math.min(visualBounds.xMax - drawSize.w, Math.max(visualBounds.xMin, Number.parseFloat(ele.dataset.xPos))),\r\n    y: Math.min(visualBounds.yMax - drawSize.h, Math.max(visualBounds.yMin, Number.parseFloat(ele.dataset.yPos))),\r\n  }\r\n\r\n  drawPos.x = drawPos.x + (Number.parseFloat(ele.dataset.xDir) * dt * 1200)\r\n  drawPos.y = drawPos.y + (Number.parseFloat(ele.dataset.yDir) * dt * 1200)\r\n\r\n  if (drawPos.x < visualBounds.xMin || drawPos.x > visualBounds.xMax - drawSize.w) {\r\n    drawPos.x = Math.min(visualBounds.xMax, Math.max(visualBounds.xMin, drawPos.x - (Number.parseFloat(ele.dataset.xDir) * dt * 155)))\r\n    ele.dataset.xDir = -Number.parseFloat(ele.dataset.xDir)\r\n    ele.style.fill = rainbow[(Math.floor(Math.random() * (rainbow.length)))]\r\n  }\r\n  if (drawPos.y < visualBounds.yMin || drawPos.y > visualBounds.yMax - drawSize.h) {\r\n    drawPos.y = Math.min(visualBounds.yMax, Math.max(visualBounds.yMin, drawPos.y - (Number.parseFloat(ele.dataset.yDir) * dt * 155)))\r\n    ele.dataset.yDir = -Number.parseFloat(ele.dataset.yDir)\r\n    ele.style.fill = rainbow[(Math.floor(Math.random() * (rainbow.length)))]\r\n  }\r\n\r\n  if (ele.dataset.cloned !== 'true') {\r\n    if (drawPos.x < visualBounds.xMin + 5 || drawPos.x > visualBounds.xMax - drawSize.w - 5) {\r\n      if (drawPos.y < visualBounds.yMin + 5 || drawPos.y > visualBounds.yMax - drawSize.h - 5) {\r\n        for (let i = 0; i <= Number.parseFloat(ele.dataset.level); i++) {\r\n          const dir = Math.random() * Math.PI * 2\r\n          addDvd({\r\n            x: drawPos.x + ((Math.random() * 10) - 5),\r\n            y: drawPos.y + ((Math.random() * 10) - 5),\r\n            xDir: Math.sin(dir),\r\n            yDir: Math.cos(dir),\r\n            id: ele.dataset.effectId,\r\n            maxLife: ele.dataset.life,\r\n            life: 0,\r\n            level: Number.parseFloat(ele.dataset.level) + 1,\r\n            cloned: 'true'\r\n          })\r\n        }\r\n        ele.dataset.cloned = 'true'\r\n      }\r\n    }\r\n  }\r\n\r\n  ele.dataset.xPos = drawPos.x\r\n  ele.dataset.yPos = drawPos.y\r\n  ele.style.left = `${drawPos.x}px`\r\n  ele.style.top = `${drawPos.y}px`\r\n  ele.dataset.lifeLeft = Number.parseFloat(ele.dataset.lifeLeft - dt)\r\n}\r\n\r\nconst drawAd = (ele, dt) => {\r\n  const drawPos = {\r\n    x: Math.min(visualBounds.xMax - ele.clientWidth, Math.max(visualBounds.xMin, Number.parseFloat(ele.dataset.xPos))),\r\n    y: Math.min(visualBounds.yMax - ele.clientHeight, Math.max(visualBounds.yMin, Number.parseFloat(ele.dataset.yPos))),\r\n  }\r\n  ele.dataset.lifeLeft = Number.parseFloat(ele.dataset.lifeLeft) - dt\r\n\r\n  ele.dataset.xPos = drawPos.x\r\n  ele.dataset.yPos = drawPos.y\r\n  ele.style.left = `${drawPos.x}px`\r\n  ele.style.top = `${drawPos.y}px`\r\n\r\n  if (Number.parseFloat(ele.dataset.lifeLeft) < Number.parseFloat(ele.dataset.inOutTime) / 1000) {\r\n    ele.classList.add('ad-in-out')\r\n  }\r\n  else if (Number.parseFloat(ele.dataset.lifeLeft) < Number.parseFloat(ele.dataset.maxLife) - Number.parseFloat(ele.dataset.inOutTime) / 1000) {\r\n    ele.classList.remove('ad-in-out')\r\n  }\r\n  else if (Number.parseFloat(ele.dataset.lifeLeft) < Number.parseFloat(ele.dataset.maxLife)) {\r\n    ele.classList.remove('btc-hidden')\r\n  }\r\n\r\n  const title = ele.querySelector('.btc-ad-flash')\r\n  if (title) {\r\n    if (Math.floor(Number.parseFloat(ele.dataset.lifeLeft) * 4 % 2) == 0) {\r\n      title.style.color = title.dataset.offcolor || 'red'\r\n    }\r\n    else {\r\n      title.style.color = title.dataset.oncolor || 'blue'\r\n    }\r\n  }\r\n}\r\n\r\nconst shakeElement = (ele, shakeLevel) => {\r\n  const currentShakeOffset = {\r\n    x: ele.style.left.substring(0, -2),\r\n    y: ele.style.top.substring(0, -2),\r\n  }\r\n\r\n  const shakeOffset = {\r\n    x: (currentShakeOffset.x / 1.2) + ((Math.random() - 0.5) * shakeLevel),\r\n    y: (currentShakeOffset.y / 1.2) + ((Math.random() - 0.5) * shakeLevel),\r\n  }\r\n\r\n  ele.style.left = `${shakeOffset.x}px`\r\n  ele.style.top = `${shakeOffset.y}px`\r\n}\r\n\r\nconst updateUI = (time) => {\r\n  const dt = frameTime// time - prevDrawTime\r\n  drawTime += dt\r\n\r\n  visualBounds.xMin = blackoutContainer.offsetLeft + shakePos.x\r\n  visualBounds.xMax = blackoutContainer.offsetLeft + blackoutContainer.clientWidth + shakePos.x\r\n  visualBounds.yMin = blackoutContainer.offsetTop + shakePos.y\r\n  visualBounds.yMax = blackoutContainer.offsetTop + blackoutContainer.clientHeight + shakePos.y\r\n\r\n  if (prevDrawTime !== time) {\r\n    clearCanvas()\r\n    shakeElement(comboCountInner, (comboCountInner.dataset.effectCount / 10) || 0)\r\n    Array.from(comboCountInner.children).forEach(child => {\r\n      child.style.animationDuration = `${Math.max(3, 20 - (comboCountInner.dataset.effectCount / 5) || 0)}s`\r\n      child.style.fontSize = `${Math.max(100, 100 + (comboCountInner.dataset.effectCount / 5) || 0)}px`\r\n      child.children[0].style.textShadow = `0 0 ${Math.max(2, 2 + ((comboCountInner.dataset.effectCount / 25) || 0))}px black`\r\n    })\r\n\r\n    const drawnElements = effectContainer.querySelectorAll('[data-effect-id]')\r\n    const drawnKeys = {}\r\n    drawnElements.forEach(ele => {\r\n      const eleId = ele.dataset.effectId\r\n      if (drawnKeys[eleId]) {\r\n        drawnKeys[eleId].push(ele)\r\n      }\r\n      else {\r\n        drawnKeys[eleId] = [ele]\r\n      }\r\n      switch (ele.dataset.type) {\r\n        case 'dvd':\r\n          drawDvd(ele, dt)// / 1000)\r\n          break\r\n        case 'ad':\r\n          drawAd(ele, dt)// / 1000)\r\n          break\r\n      }\r\n    })\r\n\r\n    const callKeys = Object.keys(drawCalls)\r\n    callKeys.forEach(id => {\r\n      switch (drawCalls[id].type) {\r\n        case 'dvd':\r\n          if (!drawnKeys[id]) {\r\n            for (let i = 0; i < drawCalls[id].data.count; i++) {\r\n              addDvd(drawCalls[id].data)\r\n            }\r\n          }\r\n          else {\r\n            //drawnKeys[id].forEach(ele => drawDvd(ele, drawCalls[id].data, dt / 1000))\r\n          }\r\n          break;\r\n        case 'ad':\r\n          if (!drawnKeys[id]) {\r\n            for (let i = 0; i < drawCalls[id].data.count; i++) {\r\n              addAd(drawCalls[id].data)\r\n            }\r\n          }\r\n          else {\r\n            //drawnKeys[id].forEach(ele => drawAd(ele, drawCalls[id].data, dt))\r\n          }\r\n          break;\r\n        default:\r\n      }\r\n    })\r\n\r\n    drawnElements.forEach(ele => {\r\n      if (ele.dataset.lifeLeft <= -0.1) {\r\n        ele.remove()\r\n      }\r\n    })\r\n\r\n    drawCalls = {}\r\n    drawTime = 0\r\n  }\r\n\r\n  prevDrawTime = time\r\n  requestAnimationFrame(updateUI)\r\n}\r\n\r\nconst initialize = (scope) => {\r\n  effectContainer = scope.rootElement.querySelector('.btc-effect-container')\r\n  copyContainer = scope.rootElement.querySelector('.btc-copy-container')\r\n  levelContainer = scope.rootElement.querySelector('.btc-combo-level-container')\r\n  comboCount = scope.rootElement.querySelector('.btc-combo-count')\r\n  comboCountInner = scope.rootElement.querySelector('.btc-combo-count-inner')\r\n  canvasEle = scope.rootElement.querySelector('.fullscreen-canvas')\r\n  context = canvasEle.getContext('2d')\r\n  blackoutContainer = effectContainer.querySelector('.btc-effect-blackout-container')\r\n\r\n  window.addEventListener('resize', () => {\r\n    windowSize.w = effectContainer.clientWidth\r\n    windowSize.h = effectContainer.clientHeight\r\n\r\n    visualBounds.xMin = blackoutContainer.offsetLeft + shakePos.x\r\n    visualBounds.xMax = blackoutContainer.offsetLeft + blackoutContainer.clientWidth + shakePos.x\r\n    visualBounds.yMin = blackoutContainer.offsetTop + shakePos.y\r\n    visualBounds.yMax = blackoutContainer.offsetTop + blackoutContainer.clientHeight + shakePos.y\r\n\r\n    canvasEle.style.width = `${windowSize.w}px`\r\n    canvasEle.style.height = `${windowSize.h}px`\r\n    canvasEle.width = windowSize.w\r\n    canvasEle.height = windowSize.h\r\n\r\n    clearCanvas()\r\n  })\r\n\r\n  setTimeout(() => {\r\n    windowSize.w = effectContainer.clientWidth\r\n    windowSize.h = effectContainer.clientHeight\r\n\r\n    visualBounds.xMin = blackoutContainer.offsetLeft + shakePos.x\r\n    visualBounds.xMax = blackoutContainer.offsetLeft + blackoutContainer.clientWidth + shakePos.x\r\n    visualBounds.yMin = blackoutContainer.offsetTop + shakePos.y\r\n    visualBounds.yMax = blackoutContainer.offsetTop + blackoutContainer.clientHeight + shakePos.y\r\n\r\n    canvasEle.style.width = `${windowSize.w}px`\r\n    canvasEle.style.height = `${windowSize.h}px`\r\n    canvasEle.width = windowSize.w\r\n    canvasEle.height = windowSize.h\r\n\r\n    clearCanvas()\r\n  }, 50)\r\n\r\n  scope.$on('BTCEffect-dvd', (e, data) => {\r\n    const keys = Object.keys(data).filter(c => c !== 'count')\r\n    keys.forEach(id => {\r\n      drawCalls[id] = {\r\n        type: 'dvd',\r\n        data: data[id],\r\n      }\r\n    });\r\n  })\r\n\r\n  scope.$on('BTCEffect-ad', (e, data) => {\r\n    const keys = Object.keys(data).filter(c => c !== 'count')\r\n    keys.forEach(id => {\r\n      drawCalls[id] = {\r\n        type: 'ad',\r\n        data: data[id],\r\n      }\r\n    });\r\n  })\r\n\r\n  scope.$on('BTCEffect-clear', () => {\r\n    const drawnElements = effectContainer.querySelectorAll('[data-effect-id]')\r\n\r\n    drawnElements.forEach(ele => {\r\n      ele.remove()\r\n    })\r\n    drawCalls = {}\r\n  })\r\n\r\n  scope.$on('BTCEffect-screen', (e, data) => {\r\n    if (data.shakeLife) {\r\n      shakePos.x = (shakePos.x / 1.02) + ((Math.random() - 0.5) * Math.min(Math.max(1, data.shakeLevel), 10) * 15)\r\n      shakePos.y = (shakePos.y / 1.02) + ((Math.random() - 0.5) * Math.min(Math.max(1, data.shakeLevel), 10) * 15)\r\n\r\n      blackoutContainer.style.transform = `translate(${shakePos.x}px, ${shakePos.y}px)`\r\n    }\r\n    else {\r\n      shakePos.x = 0\r\n      shakePos.y = 0\r\n\r\n      blackoutContainer.style.transform = `translate(${shakePos.x}px, ${shakePos.y}px)`\r\n    }\r\n    if (data.squishLife > 0) {\r\n      blackoutContainer.style.width = `calc(100vw - ${32 + data.squishLevel}vw)`\r\n      blackoutContainer.style.left = `calc(${16 + data.squishLevel}vw)`\r\n    }\r\n    else {\r\n      blackoutContainer.style.width = `calc(100vw)`\r\n      blackoutContainer.style.left = `0px`\r\n    }\r\n    if (data.narrowLife > 0) {\r\n      blackoutContainer.style.height = `calc(100vh - ${32 + data.narrowLevel}vh)`\r\n      blackoutContainer.style.top = `calc(${16 + data.narrowLevel}vh)`\r\n    }\r\n    else {\r\n      blackoutContainer.style.height = `calc(100vh)`\r\n      blackoutContainer.style.top = `0px`\r\n    }\r\n  })\r\n\r\n  scope.$on('BTCFrameUpdate', (e, data) => {\r\n    frameTime = data\r\n  })\r\n\r\n  comboCountInner.addEventListener('click', (e) => {\r\n    let count = 1\r\n    if (e.shiftKey) {\r\n      count *= 10\r\n    }\r\n    if (e.ctrlKey) {\r\n      count *= 5\r\n    }\r\n    console.log(count)\r\n    bngApi.engineLua(`freeroam_beamTwitchChaos.addRandomCommand(${count})`)\r\n  })\r\n\r\n  requestAnimationFrame(updateUI)\r\n}\n\n//# sourceURL=webpack://beamtwitchchaos/./src/js/ui-effects.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/index.js");
/******/ 	
/******/ })()
;